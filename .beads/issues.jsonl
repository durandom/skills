{"id":"durandom-42q","title":"Layton Stage 0 Foundation","description":"## Overview\n\nLayton Stage 0: Minimal CLI proving Beads integration and providing temporal context. Establishes the foundation before skill aggregation or AI synthesis.\n\n**Secretary Analogy:**\n- Beads = \"Her Notepad\" (mutable state management)\n- .layton/ = \"Her Filing Cabinet\" (stable configuration)\n- Thin CLI = Deterministic operations only\n\n## Spec Path\n\nopenspec/changes/layton-stage0-foundation/\n\n## Tasks\n\n1. Project Setup - Directory structure, CLI entrypoint, test fixtures\n2. CLI Framework - argparse, OutputFormatter, JSON responses, exit codes\n3. Doctor Command - Health checks (beads_available, config_exists, etc.)\n4. Config Commands - init, show, keys, get, set with dot-notation\n5. Context Command - Temporal context (time_of_day, work_hours)\n6. SKILL.md and Workflows - Router pattern, workflow files, references\n7. Integration \u0026 Documentation - Test suite, manual testing\n\n## Exit Criteria\n\n```bash\n# All tests pass\nuv run pytest tests/layton/ -v\n\n# CLI works\n./skills/layton/scripts/layton doctor\n./skills/layton/scripts/layton context --human\n./skills/layton/scripts/layton config show\n\n# Beads integration\nbd info --json\n```","status":"closed","priority":2,"issue_type":"epic","owner":"hild@b4mad.net","created_at":"2026-01-15T17:13:00.7913+01:00","created_by":"Marcel Hild","updated_at":"2026-01-15T18:01:53.433345+01:00","closed_at":"2026-01-15T18:01:53.433345+01:00","close_reason":"Done: Layton Stage 0 Foundation complete - all 7 tasks implemented with 76 passing tests","labels":["openspec:layton-stage0-foundation"]}
{"id":"durandom-42q.1","title":"Project Setup - Directory structure and CLI entrypoint","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/layton-stage0-foundation/design.md\n**Task**: 1.1-1.4 from tasks.md\n\n## Requirements\n\nCreate the Layton skill directory structure following the flat package pattern.\n\n**Directory Structure (EXACT):**\n```\nskills/layton/\n├── SKILL.md                  # Placeholder (populated in task 6)\n├── scripts/\n│   └── layton                # CLI entrypoint (thin wrapper)\n└── laytonlib/                # Flat package\n    ├── __init__.py           # Package init\n    ├── __main__.py           # Enables: python -m laytonlib\n    ├── cli.py                # argparse CLI (task 2)\n    ├── config.py             # Config loading (task 4)\n    ├── context.py            # Temporal context (task 5)\n    ├── doctor.py             # Health checks (task 3)\n    └── formatters.py         # OutputFormatter (task 2)\n\ntests/layton/                 # Test directory\n├── conftest.py               # Shared fixtures\n├── unit/                     # Fast, isolated tests\n│   └── .gitkeep\n└── e2e/                      # CLI integration tests\n    └── .gitkeep\n```\n\n## Reference Implementation\n\n### CREATE FILE: `skills/layton/scripts/layton`\n\n```python\n#!/usr/bin/env python3\n\"\"\"Layton CLI entrypoint.\n\nThin wrapper that invokes laytonlib.cli.main().\n\"\"\"\nimport sys\nfrom pathlib import Path\n\n# Add laytonlib to path (sibling directory)\nscript_dir = Path(__file__).parent.resolve()\nlaytonlib_dir = script_dir.parent / \"laytonlib\"\nsys.path.insert(0, str(laytonlib_dir.parent))\n\nfrom laytonlib.cli import main\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n### CREATE FILE: `skills/layton/laytonlib/__init__.py`\n\n```python\n\"\"\"Layton CLI library.\n\nPersonal AI assistant for attention management.\n\"\"\"\n__version__ = \"0.1.0\"\n```\n\n### CREATE FILE: `skills/layton/laytonlib/__main__.py`\n\n```python\n\"\"\"Enable running as: python -m laytonlib\"\"\"\nfrom laytonlib.cli import main\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### CREATE FILE: `skills/layton/laytonlib/cli.py` (stub)\n\n```python\n\"\"\"Layton CLI - argparse structure.\"\"\"\nimport argparse\nimport sys\n\n\ndef main() -\u003e int:\n    \"\"\"CLI entrypoint.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"layton\",\n        description=\"Personal AI assistant for attention management\",\n    )\n    parser.add_argument(\"--version\", action=\"version\", version=\"%(prog)s 0.1.0\")\n    \n    # Placeholder - will be populated in task 2\n    args = parser.parse_args()\n    \n    # No-arg default: run doctor (task 2 will implement)\n    print('{\"success\": true, \"message\": \"CLI stub - implement in task 2\"}')\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n### CREATE FILE: `skills/layton/laytonlib/formatters.py` (stub)\n\n```python\n\"\"\"Output formatting for Layton CLI.\"\"\"\n# Stub - will be populated in task 2\n```\n\n### CREATE FILE: `skills/layton/laytonlib/doctor.py` (stub)\n\n```python\n\"\"\"Health check logic for layton doctor.\"\"\"\n# Stub - will be populated in task 3\n```\n\n### CREATE FILE: `skills/layton/laytonlib/config.py` (stub)\n\n```python\n\"\"\"Configuration loading and management.\"\"\"\n# Stub - will be populated in task 4\n```\n\n### CREATE FILE: `skills/layton/laytonlib/context.py` (stub)\n\n```python\n\"\"\"Temporal context for Layton.\"\"\"\n# Stub - will be populated in task 5\n```\n\n### CREATE FILE: `skills/layton/SKILL.md` (placeholder)\n\n```markdown\n---\nname: layton\ndescription: Personal AI assistant for attention management. Stage 0 stub.\n---\n\n\u003c!-- Placeholder - will be populated in task 6 --\u003e\n```\n\n### CREATE FILE: `tests/layton/conftest.py`\n\n```python\n\"\"\"Shared pytest fixtures for Layton tests.\"\"\"\nimport shutil\nfrom pathlib import Path\n\nimport pytest\n\n\n@pytest.fixture\ndef isolated_env(tmp_path, monkeypatch):\n    \"\"\"Fully isolated environment with temp .layton/ and .beads/.\"\"\"\n    # Create isolated directories\n    layton_dir = tmp_path / \".layton\"\n    layton_dir.mkdir()\n    beads_dir = tmp_path / \".beads\"\n    beads_dir.mkdir()\n\n    # Change working directory to temp (isolates bd auto-detection)\n    monkeypatch.chdir(tmp_path)\n\n    return tmp_path\n\n\n@pytest.fixture\ndef temp_config(isolated_env):\n    \"\"\"Temporary .layton/config.json for isolated tests.\"\"\"\n    config_path = isolated_env / \".layton\" / \"config.json\"\n    return config_path\n\n\n@pytest.fixture\ndef mock_beads_available(monkeypatch):\n    \"\"\"Mock bd CLI availability check (unit tests only).\"\"\"\n    monkeypatch.setattr(shutil, \"which\", lambda cmd: \"/usr/bin/bd\" if cmd == \"bd\" else None)\n\n\n@pytest.fixture\ndef mock_beads_unavailable(monkeypatch):\n    \"\"\"Mock bd CLI as unavailable (unit tests only).\"\"\"\n    monkeypatch.setattr(shutil, \"which\", lambda cmd: None)\n\n\n@pytest.fixture\ndef real_beads_isolated(isolated_env):\n    \"\"\"Real bd CLI in isolated temp directory (integration tests).\"\"\"\n    # bd will auto-init in isolated_env/.beads/ on first write\n    return isolated_env / \".beads\"\n```\n\n## Exit Criteria\n\n```bash\n# Directory structure exists\nls -la skills/layton/\nls -la skills/layton/scripts/\nls -la skills/layton/laytonlib/\nls -la tests/layton/\n\n# CLI entrypoint is executable\nchmod +x skills/layton/scripts/layton\n./skills/layton/scripts/layton --version\n\n# Python module works\ncd skills/layton \u0026\u0026 python -m laytonlib --version\n\n# Tests directory has conftest\ncat tests/layton/conftest.py\n```\n\n### Checklist\n- [ ] skills/layton/scripts/layton exists and is executable\n- [ ] skills/layton/laytonlib/__init__.py exports __version__\n- [ ] skills/layton/laytonlib/__main__.py enables python -m laytonlib\n- [ ] skills/layton/laytonlib/cli.py has main() stub\n- [ ] All stub files exist (formatters.py, doctor.py, config.py, context.py)\n- [ ] tests/layton/conftest.py has isolated_env, temp_config, mock_beads_* fixtures\n- [ ] SKILL.md placeholder exists\n\n## Files to Create\n\n- `skills/layton/scripts/layton` (CREATE) - CLI entrypoint, make executable\n- `skills/layton/laytonlib/__init__.py` (CREATE) - Package init\n- `skills/layton/laytonlib/__main__.py` (CREATE) - Module runner\n- `skills/layton/laytonlib/cli.py` (CREATE) - CLI stub\n- `skills/layton/laytonlib/formatters.py` (CREATE) - Stub\n- `skills/layton/laytonlib/doctor.py` (CREATE) - Stub\n- `skills/layton/laytonlib/config.py` (CREATE) - Stub\n- `skills/layton/laytonlib/context.py` (CREATE) - Stub\n- `skills/layton/SKILL.md` (CREATE) - Placeholder\n- `tests/layton/conftest.py` (CREATE) - Test fixtures\n- `tests/layton/unit/.gitkeep` (CREATE) - Directory placeholder\n- `tests/layton/e2e/.gitkeep` (CREATE) - Directory placeholder","status":"closed","priority":1,"issue_type":"task","owner":"hild@b4mad.net","created_at":"2026-01-15T17:13:36.272724+01:00","created_by":"Marcel Hild","updated_at":"2026-01-15T17:37:13.885701+01:00","closed_at":"2026-01-15T17:37:13.885701+01:00","close_reason":"Done: Created Layton directory structure, CLI entrypoint, laytonlib package with all stub files, and test fixtures","labels":["openspec:layton-stage0-foundation"],"dependencies":[{"issue_id":"durandom-42q.1","depends_on_id":"durandom-42q","type":"parent-child","created_at":"2026-01-15T17:13:36.274194+01:00","created_by":"Marcel Hild"}]}
{"id":"durandom-42q.2","title":"CLI Framework - argparse, OutputFormatter, JSON responses","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/layton-stage0-foundation/specs/cli-framework/spec.md\n**Task**: 2.1-2.5 from tasks.md\n\n## Requirements\n\nImplement the CLI framework with global options and consistent output formatting.\n\n**From cli-framework spec:**\n\n1. **No-arg invocation**: \n   - `layton` with no args SHALL run `layton doctor`\n   - `layton config` with no subcommand SHALL run `layton config show`\n\n2. **Global CLI options**:\n   - `--human`: Human-readable output (colors, tables)\n   - `--verbose`: Include debug info in JSON\n   - `--help`: Display help text\n   - `--version`: Display package version\n\n3. **Output format consistency (JSON by default - agent-first)**:\n   - Success: `{\"success\": true, \"data\": {...}, \"next_steps\": [...]}`\n   - Error: `{\"success\": false, \"error\": {\"code\": \"...\", \"message\": \"...\"}, \"next_steps\": [...]}`\n   - JSON is DEFAULT (no flag needed); `--human` enables human output\n\n4. **Exit codes**:\n   - 0 = success\n   - 1 = fixable issues\n   - 2 = critical issues\n\n## Reference Implementation\n\n### REPLACE FILE: `skills/layton/laytonlib/cli.py`\n\n```python\n\"\"\"Layton CLI - argparse structure with global options.\"\"\"\nimport argparse\nimport sys\nfrom typing import Optional\n\nfrom laytonlib import __version__\nfrom laytonlib.formatters import OutputFormatter\n\n\ndef create_parser() -\u003e argparse.ArgumentParser:\n    \"\"\"Create the argument parser with all commands.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"layton\",\n        description=\"Personal AI assistant for attention management\",\n    )\n    parser.add_argument(\"--version\", action=\"version\", version=f\"%(prog)s {__version__}\")\n    parser.add_argument(\n        \"--human\",\n        action=\"store_true\",\n        help=\"Human-readable output (default is JSON)\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"Include debug information\",\n    )\n\n    subparsers = parser.add_subparsers(dest=\"command\")\n\n    # doctor command\n    doctor_parser = subparsers.add_parser(\"doctor\", help=\"Check system health\")\n    # Hidden --fix flag (not shown in help, but works)\n    doctor_parser.add_argument(\n        \"--fix\",\n        action=\"store_true\",\n        help=argparse.SUPPRESS,  # Hidden from help\n    )\n\n    # config command\n    config_parser = subparsers.add_parser(\"config\", help=\"Manage configuration\")\n    config_subparsers = config_parser.add_subparsers(dest=\"config_command\")\n\n    # config init\n    config_init = config_subparsers.add_parser(\"init\", help=\"Create default config\")\n    config_init.add_argument(\n        \"--force\",\n        action=\"store_true\",\n        help=\"Overwrite existing config\",\n    )\n\n    # config show\n    config_subparsers.add_parser(\"show\", help=\"Display current config\")\n\n    # config keys\n    config_subparsers.add_parser(\"keys\", help=\"List all config keys\")\n\n    # config get\n    config_get = config_subparsers.add_parser(\"get\", help=\"Get a config value\")\n    config_get.add_argument(\"key\", help=\"Key in dot notation (e.g., work.schedule.start)\")\n\n    # config set\n    config_set = config_subparsers.add_parser(\"set\", help=\"Set a config value\")\n    config_set.add_argument(\"key\", help=\"Key in dot notation\")\n    config_set.add_argument(\"value\", help=\"Value to set (JSON parsed if valid)\")\n\n    # context command\n    subparsers.add_parser(\"context\", help=\"Show temporal context\")\n\n    return parser\n\n\ndef main(argv: Optional[list[str]] = None) -\u003e int:\n    \"\"\"CLI entrypoint.\n\n    Args:\n        argv: Command line arguments (defaults to sys.argv[1:])\n\n    Returns:\n        Exit code (0=success, 1=fixable, 2=critical)\n    \"\"\"\n    parser = create_parser()\n    args = parser.parse_args(argv)\n\n    # Create formatter based on --human flag\n    formatter = OutputFormatter(human=args.human, verbose=args.verbose)\n\n    # No-arg default: run doctor\n    if args.command is None:\n        args.command = \"doctor\"\n        args.fix = False\n\n    # Route to command handlers\n    if args.command == \"doctor\":\n        from laytonlib.doctor import run_doctor\n        return run_doctor(formatter, fix=getattr(args, \"fix\", False))\n\n    elif args.command == \"config\":\n        from laytonlib.config import run_config\n        # No subcommand default: show\n        config_cmd = args.config_command or \"show\"\n        return run_config(\n            formatter,\n            config_cmd,\n            key=getattr(args, \"key\", None),\n            value=getattr(args, \"value\", None),\n            force=getattr(args, \"force\", False),\n        )\n\n    elif args.command == \"context\":\n        from laytonlib.context import run_context\n        return run_context(formatter)\n\n    else:\n        # Unknown command - shouldn't happen with argparse\n        formatter.error(\"UNKNOWN_COMMAND\", f\"Unknown command: {args.command}\")\n        return 2\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n### REPLACE FILE: `skills/layton/laytonlib/formatters.py`\n\n```python\n\"\"\"Output formatting for Layton CLI.\n\nJSON is the default output format (agent-first design).\nUse --human flag for human-readable output.\n\"\"\"\nimport json\nimport sys\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\n\n@dataclass\nclass OutputFormatter:\n    \"\"\"Formats CLI output as JSON (default) or human-readable.\n\n    Usage:\n        formatter = OutputFormatter(human=args.human)\n        formatter.success({\"key\": \"value\"}, next_steps=[\"do this\"])\n        formatter.error(\"ERROR_CODE\", \"Something went wrong\")\n    \"\"\"\n\n    human: bool = False\n    verbose: bool = False\n    _debug_info: dict[str, Any] = field(default_factory=dict)\n\n    def add_debug(self, key: str, value: Any) -\u003e None:\n        \"\"\"Add debug information (included if verbose=True).\"\"\"\n        self._debug_info[key] = value\n\n    def success(\n        self,\n        data: dict[str, Any],\n        next_steps: list[str] | None = None,\n    ) -\u003e None:\n        \"\"\"Output a success response.\n\n        Args:\n            data: The response data\n            next_steps: Optional list of suggested next actions\n        \"\"\"\n        if self.human:\n            self._print_human_success(data, next_steps)\n        else:\n            response = {\n                \"success\": True,\n                \"data\": data,\n                \"next_steps\": next_steps or [],\n            }\n            if self.verbose and self._debug_info:\n                response[\"debug\"] = self._debug_info\n            print(json.dumps(response, indent=2))\n\n    def error(\n        self,\n        code: str,\n        message: str,\n        next_steps: list[str] | None = None,\n    ) -\u003e None:\n        \"\"\"Output an error response.\n\n        Args:\n            code: Error code (e.g., CONFIG_MISSING)\n            message: Human-readable error message\n            next_steps: Optional list of recovery suggestions\n        \"\"\"\n        if self.human:\n            self._print_human_error(code, message, next_steps)\n        else:\n            response = {\n                \"success\": False,\n                \"error\": {\n                    \"code\": code,\n                    \"message\": message,\n                },\n                \"next_steps\": next_steps or [],\n            }\n            if self.verbose and self._debug_info:\n                response[\"debug\"] = self._debug_info\n            print(json.dumps(response, indent=2))\n\n    def _print_human_success(\n        self,\n        data: dict[str, Any],\n        next_steps: list[str] | None,\n    ) -\u003e None:\n        \"\"\"Print human-readable success output.\"\"\"\n        # Pretty-print the data\n        for key, value in data.items():\n            if isinstance(value, dict):\n                print(f\"{key}:\")\n                for k, v in value.items():\n                    print(f\"  {k}: {v}\")\n            elif isinstance(value, list):\n                print(f\"{key}:\")\n                for item in value:\n                    if isinstance(item, dict):\n                        for k, v in item.items():\n                            print(f\"  {k}: {v}\")\n                        print()\n                    else:\n                        print(f\"  - {item}\")\n            else:\n                print(f\"{key}: {value}\")\n\n        if next_steps:\n            print()\n            print(\"Next steps:\")\n            for step in next_steps:\n                print(f\"  - {step}\")\n\n    def _print_human_error(\n        self,\n        code: str,\n        message: str,\n        next_steps: list[str] | None,\n    ) -\u003e None:\n        \"\"\"Print human-readable error output.\"\"\"\n        print(f\"Error [{code}]: {message}\", file=sys.stderr)\n\n        if next_steps:\n            print()\n            print(\"To fix:\")\n            for step in next_steps:\n                print(f\"  - {step}\")\n```\n\n## Exit Criteria\n\n```bash\n# CLI accepts global options\n./skills/layton/scripts/layton --help\n./skills/layton/scripts/layton --version\n./skills/layton/scripts/layton --human doctor\n\n# No-arg defaults work (will fail on doctor checks - that's expected)\n./skills/layton/scripts/layton  # runs doctor\n\n# JSON output by default\n./skills/layton/scripts/layton doctor 2\u003e\u00261 | python -c \"import json,sys; json.load(sys.stdin)\"\n\n# Human output with flag\n./skills/layton/scripts/layton --human doctor\n```\n\n### Checklist\n- [ ] `layton --help` shows all commands and global options\n- [ ] `layton --version` shows version\n- [ ] `layton` (no args) runs `layton doctor`\n- [ ] `layton config` (no subcommand) runs `layton config show`\n- [ ] Default output is valid JSON with success, data, next_steps fields\n- [ ] `--human` flag produces human-readable output\n- [ ] `--verbose` includes debug info in JSON\n- [ ] `--fix` flag is hidden from help but functional\n- [ ] OutputFormatter handles both success and error responses\n\n## Files to Modify\n\n- `skills/layton/laytonlib/cli.py` (REPLACE) - Full CLI implementation\n- `skills/layton/laytonlib/formatters.py` (REPLACE) - OutputFormatter class","status":"closed","priority":1,"issue_type":"task","owner":"hild@b4mad.net","created_at":"2026-01-15T17:14:14.683733+01:00","created_by":"Marcel Hild","updated_at":"2026-01-15T17:51:15.582376+01:00","closed_at":"2026-01-15T17:51:15.582376+01:00","close_reason":"Done: Implemented CLI framework with argparse, OutputFormatter, JSON default output, --human flag, and command routing","labels":["openspec:layton-stage0-foundation"],"dependencies":[{"issue_id":"durandom-42q.2","depends_on_id":"durandom-42q","type":"parent-child","created_at":"2026-01-15T17:14:14.684771+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.2","depends_on_id":"durandom-42q.1","type":"blocks","created_at":"2026-01-15T17:19:03.511858+01:00","created_by":"Marcel Hild"}]}
{"id":"durandom-42q.3","title":"Doctor Command - Health checks with beads and config validation","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/layton-stage0-foundation/specs/cli-doctor/spec.md\n**Task**: 3.1-3.9 from tasks.md\n\n## Requirements\n\nImplement `layton doctor` command with health checks.\n\n**From cli-doctor spec:**\n\n1. **Health check categories** - Each check has:\n   - `name`: Check identifier (e.g., \"beads_available\")\n   - `status`: One of \"pass\", \"warn\", \"fail\"\n   - `message`: Human-readable explanation\n\n2. **beads_available check**:\n   - Pass: `bd` in PATH AND `bd info --json` succeeds\n   - Fail (exit 2): `bd` not found - CRITICAL\n\n3. **beads_initialized check**:\n   - Pass: `.beads/` directory exists\n   - Warn: `.beads/` missing (suggest `bd init`)\n\n4. **config_exists check**:\n   - Pass: `.layton/config.json` exists\n   - Fail (exit 1): config missing - FIXABLE\n\n5. **config_valid check**:\n   - Pass: config is valid JSON\n   - Fail: config has JSON parse error\n\n6. **Hidden --fix flag**:\n   - Creates `.layton/config.json` with defaults\n   - Suggested in next_steps when config missing\n   - NOT shown in --help\n\n7. **Exit codes**:\n   - 0: All checks pass\n   - 1: Fixable issues (config missing)\n   - 2: Critical issues (beads missing)\n\n## Reference Implementation\n\n### REPLACE FILE: `skills/layton/laytonlib/doctor.py`\n\n```python\n\"\"\"Health check logic for layton doctor.\n\nValidates system setup and dependencies.\n\"\"\"\nimport json\nimport shutil\nimport subprocess\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Literal\n\nfrom laytonlib.formatters import OutputFormatter\n\n\n@dataclass\nclass CheckResult:\n    \"\"\"Result of a single health check.\"\"\"\n    name: str\n    status: Literal[\"pass\", \"warn\", \"fail\"]\n    message: str\n\n    def to_dict(self) -\u003e dict:\n        return {\n            \"name\": self.name,\n            \"status\": self.status,\n            \"message\": self.message,\n        }\n\n\ndef find_git_root() -\u003e Path | None:\n    \"\"\"Find the git repository root, or None if not in a repo.\"\"\"\n    try:\n        result = subprocess.run(\n            [\"git\", \"rev-parse\", \"--show-toplevel\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        return Path(result.stdout.strip())\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        return None\n\n\ndef get_layton_dir() -\u003e Path:\n    \"\"\"Get the .layton directory path (in git root or cwd).\"\"\"\n    git_root = find_git_root()\n    base = git_root if git_root else Path.cwd()\n    return base / \".layton\"\n\n\ndef get_config_path() -\u003e Path:\n    \"\"\"Get the config.json path.\"\"\"\n    return get_layton_dir() / \"config.json\"\n\n\ndef check_beads_available() -\u003e CheckResult:\n    \"\"\"Check if bd CLI is available and working.\"\"\"\n    # Check if bd is in PATH\n    bd_path = shutil.which(\"bd\")\n    if not bd_path:\n        return CheckResult(\n            name=\"beads_available\",\n            status=\"fail\",\n            message=\"bd CLI not found in PATH. Install Beads: https://github.com/steveyegge/beads\",\n        )\n\n    # Check if bd info --json works\n    try:\n        result = subprocess.run(\n            [\"bd\", \"info\", \"--json\"],\n            capture_output=True,\n            text=True,\n            timeout=5,\n        )\n        if result.returncode == 0:\n            return CheckResult(\n                name=\"beads_available\",\n                status=\"pass\",\n                message=f\"bd CLI available at {bd_path}\",\n            )\n        else:\n            return CheckResult(\n                name=\"beads_available\",\n                status=\"fail\",\n                message=f\"bd CLI found but 'bd info --json' failed: {result.stderr.strip()}\",\n            )\n    except subprocess.TimeoutExpired:\n        return CheckResult(\n            name=\"beads_available\",\n            status=\"fail\",\n            message=\"bd CLI found but 'bd info --json' timed out\",\n        )\n    except Exception as e:\n        return CheckResult(\n            name=\"beads_available\",\n            status=\"fail\",\n            message=f\"bd CLI found but failed to execute: {e}\",\n        )\n\n\ndef check_beads_initialized() -\u003e CheckResult:\n    \"\"\"Check if .beads/ directory exists.\"\"\"\n    git_root = find_git_root()\n    base = git_root if git_root else Path.cwd()\n    beads_dir = base / \".beads\"\n\n    if beads_dir.exists():\n        return CheckResult(\n            name=\"beads_initialized\",\n            status=\"pass\",\n            message=f\"Beads initialized at {beads_dir}\",\n        )\n    else:\n        return CheckResult(\n            name=\"beads_initialized\",\n            status=\"warn\",\n            message=\"Beads not initialized. Run 'bd init' to create .beads/\",\n        )\n\n\ndef check_config_exists() -\u003e CheckResult:\n    \"\"\"Check if .layton/config.json exists.\"\"\"\n    config_path = get_config_path()\n\n    if config_path.exists():\n        return CheckResult(\n            name=\"config_exists\",\n            status=\"pass\",\n            message=f\"Config found at {config_path}\",\n        )\n    else:\n        return CheckResult(\n            name=\"config_exists\",\n            status=\"fail\",\n            message=f\"Config missing at {config_path}\",\n        )\n\n\ndef check_config_valid() -\u003e CheckResult:\n    \"\"\"Check if config.json is valid JSON.\"\"\"\n    config_path = get_config_path()\n\n    if not config_path.exists():\n        return CheckResult(\n            name=\"config_valid\",\n            status=\"fail\",\n            message=\"Cannot validate config - file does not exist\",\n        )\n\n    try:\n        with open(config_path) as f:\n            json.load(f)\n        return CheckResult(\n            name=\"config_valid\",\n            status=\"pass\",\n            message=\"Config is valid JSON\",\n        )\n    except json.JSONDecodeError as e:\n        return CheckResult(\n            name=\"config_valid\",\n            status=\"fail\",\n            message=f\"Config has invalid JSON: {e}\",\n        )\n    except Exception as e:\n        return CheckResult(\n            name=\"config_valid\",\n            status=\"fail\",\n            message=f\"Cannot read config: {e}\",\n        )\n\n\ndef get_default_config() -\u003e dict:\n    \"\"\"Get default configuration values.\"\"\"\n    # Try to detect system timezone\n    try:\n        from datetime import datetime\n        tz = datetime.now().astimezone().tzinfo\n        timezone = str(tz) if tz else \"UTC\"\n    except Exception:\n        timezone = \"UTC\"\n\n    return {\n        \"timezone\": timezone,\n        \"work\": {\n            \"schedule\": {\n                \"start\": \"09:00\",\n                \"end\": \"17:00\",\n            }\n        }\n    }\n\n\ndef fix_config() -\u003e bool:\n    \"\"\"Create config with defaults. Returns True if created.\"\"\"\n    config_path = get_config_path()\n    layton_dir = get_layton_dir()\n\n    try:\n        # Create .layton/ directory if needed\n        layton_dir.mkdir(parents=True, exist_ok=True)\n\n        # Write default config\n        config = get_default_config()\n        with open(config_path, \"w\") as f:\n            json.dump(config, f, indent=2)\n        return True\n    except Exception:\n        return False\n\n\ndef run_doctor(formatter: OutputFormatter, fix: bool = False) -\u003e int:\n    \"\"\"Run all health checks.\n\n    Args:\n        formatter: Output formatter\n        fix: If True, attempt to fix fixable issues\n\n    Returns:\n        Exit code (0=success, 1=fixable, 2=critical)\n    \"\"\"\n    checks: list[CheckResult] = []\n    next_steps: list[str] = []\n\n    # Check beads availability (critical)\n    beads_check = check_beads_available()\n    checks.append(beads_check)\n\n    if beads_check.status == \"fail\":\n        # Critical failure - bd not available\n        formatter.error(\n            \"BEADS_UNAVAILABLE\",\n            beads_check.message,\n            next_steps=[\"Install Beads CLI: https://github.com/steveyegge/beads\"],\n        )\n        return 2\n\n    # Check beads initialized (warning)\n    beads_init_check = check_beads_initialized()\n    checks.append(beads_init_check)\n    if beads_init_check.status == \"warn\":\n        next_steps.append(\"Run 'bd init' to initialize Beads\")\n\n    # Check config exists (fixable)\n    config_exists_check = check_config_exists()\n    checks.append(config_exists_check)\n\n    # Check config valid (if exists)\n    config_valid_check = check_config_valid()\n    if config_exists_check.status == \"pass\":\n        checks.append(config_valid_check)\n\n    # Determine if we need to fix\n    config_missing = config_exists_check.status == \"fail\"\n    config_invalid = config_valid_check.status == \"fail\" and config_exists_check.status == \"pass\"\n\n    if fix and config_missing:\n        # Attempt to fix config\n        if fix_config():\n            # Re-run config checks\n            config_exists_check = check_config_exists()\n            config_valid_check = check_config_valid()\n            # Update checks list\n            checks = [c for c in checks if c.name not in (\"config_exists\", \"config_valid\")]\n            checks.append(config_exists_check)\n            checks.append(config_valid_check)\n            config_missing = False\n\n    # Build next_steps\n    if config_missing:\n        next_steps.append(\"Run 'layton doctor --fix' to create config with defaults\")\n        next_steps.append(\"Or run 'layton config init' to create config manually\")\n\n    if config_invalid:\n        next_steps.append(\"Fix the JSON syntax error in .layton/config.json\")\n\n    # Determine overall status\n    has_fail = any(c.status == \"fail\" for c in checks)\n    has_warn = any(c.status == \"warn\" for c in checks)\n\n    # Output results\n    data = {\n        \"checks\": [c.to_dict() for c in checks],\n        \"summary\": {\n            \"total\": len(checks),\n            \"pass\": sum(1 for c in checks if c.status == \"pass\"),\n            \"warn\": sum(1 for c in checks if c.status == \"warn\"),\n            \"fail\": sum(1 for c in checks if c.status == \"fail\"),\n        },\n    }\n\n    if has_fail:\n        # Check if only config is failing (fixable)\n        non_config_fails = [c for c in checks if c.status == \"fail\" and c.name not in (\"config_exists\", \"config_valid\")]\n        if non_config_fails:\n            formatter.error(\n                \"CRITICAL_FAILURE\",\n                \"Critical checks failed\",\n                next_steps=next_steps,\n            )\n            return 2\n        else:\n            # Only config failing - fixable\n            formatter.success(data, next_steps=next_steps)\n            return 1\n    elif has_warn:\n        formatter.success(data, next_steps=next_steps)\n        return 0  # Warnings don't affect exit code\n    else:\n        # All pass\n        if formatter.human:\n            data[\"message\"] = \"All systems go\\!\"\n        formatter.success(data, next_steps=next_steps)\n        return 0\n```\n\n### CREATE FILE: `tests/layton/unit/test_doctor.py`\n\n```python\n\"\"\"Unit tests for doctor checks.\"\"\"\nimport json\nimport pytest\nfrom pathlib import Path\n\nfrom laytonlib.doctor import (\n    check_beads_available,\n    check_beads_initialized,\n    check_config_exists,\n    check_config_valid,\n    get_default_config,\n    fix_config,\n)\n\n\nclass TestBeadsAvailable:\n    \"\"\"Tests for beads_available check.\"\"\"\n\n    def test_beads_not_in_path(self, mock_beads_unavailable):\n        \"\"\"bd CLI not found returns fail.\"\"\"\n        result = check_beads_available()\n        assert result.status == \"fail\"\n        assert result.name == \"beads_available\"\n        assert \"not found\" in result.message.lower()\n\n    def test_beads_in_path(self, mock_beads_available):\n        \"\"\"bd CLI in PATH returns pass (if bd info works).\"\"\"\n        # Note: This will fail if bd info --json actually fails\n        # For true unit tests, we'd need to mock subprocess.run too\n        result = check_beads_available()\n        # Status depends on whether bd info --json works\n        assert result.name == \"beads_available\"\n\n\nclass TestConfigExists:\n    \"\"\"Tests for config_exists check.\"\"\"\n\n    def test_config_missing(self, isolated_env):\n        \"\"\"Missing config returns fail.\"\"\"\n        # Remove config if it exists\n        config_path = isolated_env / \".layton\" / \"config.json\"\n        if config_path.exists():\n            config_path.unlink()\n\n        result = check_config_exists()\n        assert result.status == \"fail\"\n        assert result.name == \"config_exists\"\n\n    def test_config_exists(self, temp_config):\n        \"\"\"Existing config returns pass.\"\"\"\n        # Create config\n        temp_config.write_text(\"{}\")\n\n        result = check_config_exists()\n        assert result.status == \"pass\"\n        assert result.name == \"config_exists\"\n\n\nclass TestConfigValid:\n    \"\"\"Tests for config_valid check.\"\"\"\n\n    def test_valid_json(self, temp_config):\n        \"\"\"Valid JSON config returns pass.\"\"\"\n        temp_config.write_text('{\"key\": \"value\"}')\n\n        result = check_config_valid()\n        assert result.status == \"pass\"\n        assert result.name == \"config_valid\"\n\n    def test_invalid_json(self, temp_config):\n        \"\"\"Invalid JSON config returns fail.\"\"\"\n        temp_config.write_text(\"not json at all\")\n\n        result = check_config_valid()\n        assert result.status == \"fail\"\n        assert result.name == \"config_valid\"\n        assert \"invalid\" in result.message.lower()\n\n\nclass TestDefaultConfig:\n    \"\"\"Tests for default config generation.\"\"\"\n\n    def test_has_required_keys(self):\n        \"\"\"Default config has required keys.\"\"\"\n        config = get_default_config()\n\n        assert \"timezone\" in config\n        assert \"work\" in config\n        assert \"schedule\" in config[\"work\"]\n        assert \"start\" in config[\"work\"][\"schedule\"]\n        assert \"end\" in config[\"work\"][\"schedule\"]\n\n\nclass TestFixConfig:\n    \"\"\"Tests for config fix functionality.\"\"\"\n\n    def test_creates_config(self, isolated_env):\n        \"\"\"fix_config creates config file.\"\"\"\n        config_path = isolated_env / \".layton\" / \"config.json\"\n        assert not config_path.exists()\n\n        result = fix_config()\n\n        assert result is True\n        assert config_path.exists()\n\n        # Verify it's valid JSON with required keys\n        config = json.loads(config_path.read_text())\n        assert \"timezone\" in config\n        assert \"work\" in config\n```\n\n### CREATE FILE: `tests/layton/e2e/test_doctor.py`\n\n```python\n\"\"\"E2E tests for layton doctor command.\"\"\"\nimport json\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\n\ndef run_layton(*args, cwd=None):\n    \"\"\"Run layton CLI and return result.\"\"\"\n    script_path = Path(__file__).parent.parent.parent.parent / \"skills\" / \"layton\" / \"scripts\" / \"layton\"\n    result = subprocess.run(\n        [sys.executable, str(script_path), *args],\n        capture_output=True,\n        text=True,\n        cwd=cwd,\n    )\n    return result\n\n\nclass TestDoctorCommand:\n    \"\"\"E2E tests for layton doctor.\"\"\"\n\n    def test_doctor_outputs_json(self, isolated_env, mock_beads_unavailable):\n        \"\"\"doctor outputs valid JSON by default.\"\"\"\n        result = run_layton(\"doctor\", cwd=isolated_env)\n\n        # Should be valid JSON regardless of exit code\n        try:\n            data = json.loads(result.stdout)\n            assert \"success\" in data or \"error\" in data\n        except json.JSONDecodeError:\n            pytest.fail(f\"Output is not valid JSON: {result.stdout}\")\n\n    def test_doctor_no_args_runs_doctor(self, isolated_env):\n        \"\"\"layton with no args runs doctor.\"\"\"\n        result = run_layton(cwd=isolated_env)\n\n        # Should produce JSON output (doctor command)\n        try:\n            data = json.loads(result.stdout)\n            # Doctor either succeeds with checks or fails with error\n            assert \"success\" in data or \"error\" in data\n        except json.JSONDecodeError:\n            pytest.fail(f\"Output is not valid JSON: {result.stdout}\")\n\n    def test_doctor_fix_creates_config(self, isolated_env):\n        \"\"\"doctor --fix creates config when missing.\"\"\"\n        config_path = isolated_env / \".layton\" / \"config.json\"\n        assert not config_path.exists()\n\n        result = run_layton(\"doctor\", \"--fix\", cwd=isolated_env)\n\n        # If beads is available, config should be created\n        # If beads is not available, it will fail before fixing config\n        if result.returncode \\!= 2:  # Not critical beads failure\n            assert config_path.exists()\n\n    def test_doctor_human_output(self, isolated_env):\n        \"\"\"doctor --human outputs human-readable format.\"\"\"\n        result = run_layton(\"doctor\", \"--human\", cwd=isolated_env)\n\n        # Human output should NOT be JSON\n        try:\n            json.loads(result.stdout)\n            # If it parses as JSON, that's wrong for human mode\n            # (unless it's an empty response)\n            if result.stdout.strip():\n                pytest.fail(\"Human output should not be JSON\")\n        except json.JSONDecodeError:\n            pass  # Expected - human output is not JSON\n```\n\n## Exit Criteria\n\n```bash\n# Doctor command works\n./skills/layton/scripts/layton doctor\n\n# JSON output includes checks array\n./skills/layton/scripts/layton doctor | jq '.data.checks'\n\n# Exit code reflects status (will be 1 or 2 depending on setup)\n./skills/layton/scripts/layton doctor; echo \"Exit code: $?\"\n\n# Hidden --fix flag works (not in help)\n./skills/layton/scripts/layton doctor --help | grep -v fix\n./skills/layton/scripts/layton doctor --fix\n\n# Human output\n./skills/layton/scripts/layton doctor --human\n\n# Unit tests pass\nuv run pytest tests/layton/unit/test_doctor.py -v\n\n# E2E tests pass\nuv run pytest tests/layton/e2e/test_doctor.py -v\n```\n\n### Checklist\n- [ ] beads_available check verifies `bd` in PATH and `bd info --json` works\n- [ ] beads_initialized check warns if .beads/ missing\n- [ ] config_exists check fails if .layton/config.json missing\n- [ ] config_valid check fails on invalid JSON\n- [ ] Exit code 0 when all pass, 1 when config missing, 2 when bd missing\n- [ ] --fix flag creates config with defaults (hidden from help)\n- [ ] next_steps includes relevant suggestions\n- [ ] Human output shows pass/warn/fail for each check\n- [ ] Unit tests cover all check functions\n- [ ] E2E tests verify CLI behavior\n\n## Files to Modify\n\n- `skills/layton/laytonlib/doctor.py` (REPLACE) - Full implementation\n- `tests/layton/unit/test_doctor.py` (CREATE) - Unit tests\n- `tests/layton/e2e/test_doctor.py` (CREATE) - E2E tests","status":"closed","priority":1,"issue_type":"task","owner":"hild@b4mad.net","created_at":"2026-01-15T17:15:24.54454+01:00","created_by":"Marcel Hild","updated_at":"2026-01-15T17:54:25.929502+01:00","closed_at":"2026-01-15T17:54:25.929502+01:00","close_reason":"Done: Implemented doctor with all health checks, hidden --fix flag, proper exit codes, and unit+e2e tests","labels":["openspec:layton-stage0-foundation"],"dependencies":[{"issue_id":"durandom-42q.3","depends_on_id":"durandom-42q","type":"parent-child","created_at":"2026-01-15T17:15:24.545721+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.3","depends_on_id":"durandom-42q.2","type":"blocks","created_at":"2026-01-15T17:19:05.075504+01:00","created_by":"Marcel Hild"}]}
{"id":"durandom-42q.4","title":"Config Commands - init, show, keys, get, set with dot-notation","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/layton-stage0-foundation/specs/cli-config/spec.md\n**Task**: 4.1-4.10 from tasks.md\n\n## Requirements\n\nImplement `layton config` subcommands for configuration management.\n\n**From cli-config spec:**\n\n1. **Config file location**:\n   - In git repo: `\u003cgit-root\u003e/.layton/config.json`\n   - Outside git: `./.layton/config.json`\n\n2. **Commands**:\n   - `init`: Create config with defaults (error if exists)\n   - `init --force`: Overwrite existing config\n   - `show`: Dump entire config (default subcommand)\n   - `keys`: List all dot-notation paths\n   - `get \u003ckey\u003e`: Get value using dot-notation\n   - `set \u003ckey\u003e \u003cvalue\u003e`: Set value, parse JSON if valid\n\n3. **Dot-notation access**:\n   - `work.schedule.start` traverses `work` -\u003e `schedule` -\u003e `start`\n   - Missing key returns error `KEY_NOT_FOUND`\n   - `get` on object returns JSON\n\n4. **No runtime default merging**:\n   - Missing keys fail explicitly\n   - Users run `init` to get defaults\n\n## Reference Implementation\n\n### REPLACE FILE: `skills/layton/laytonlib/config.py`\n\n```python\n\"\"\"Configuration loading and management.\n\nConfig is stored at .layton/config.json relative to git root (or cwd if not in git).\nImplements a simple key-value store with dot-notation access.\n\"\"\"\nimport json\nimport subprocess\nfrom pathlib import Path\nfrom typing import Any\n\nfrom laytonlib.formatters import OutputFormatter\n\n\ndef find_git_root() -\u003e Path | None:\n    \"\"\"Find the git repository root, or None if not in a repo.\"\"\"\n    try:\n        result = subprocess.run(\n            [\"git\", \"rev-parse\", \"--show-toplevel\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        return Path(result.stdout.strip())\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        return None\n\n\ndef get_layton_dir() -\u003e Path:\n    \"\"\"Get the .layton directory path (in git root or cwd).\"\"\"\n    git_root = find_git_root()\n    base = git_root if git_root else Path.cwd()\n    return base / \".layton\"\n\n\ndef get_config_path() -\u003e Path:\n    \"\"\"Get the config.json path.\"\"\"\n    return get_layton_dir() / \"config.json\"\n\n\ndef get_default_config() -\u003e dict:\n    \"\"\"Get default configuration values.\"\"\"\n    # Try to detect system timezone\n    try:\n        from datetime import datetime\n        tz = datetime.now().astimezone().tzinfo\n        timezone = str(tz) if tz else \"UTC\"\n    except Exception:\n        timezone = \"UTC\"\n\n    return {\n        \"timezone\": timezone,\n        \"work\": {\n            \"schedule\": {\n                \"start\": \"09:00\",\n                \"end\": \"17:00\",\n            }\n        }\n    }\n\n\ndef load_config() -\u003e dict | None:\n    \"\"\"Load config from file. Returns None if not found.\"\"\"\n    config_path = get_config_path()\n    if not config_path.exists():\n        return None\n    try:\n        with open(config_path) as f:\n            return json.load(f)\n    except (json.JSONDecodeError, OSError):\n        return None\n\n\ndef save_config(config: dict) -\u003e bool:\n    \"\"\"Save config to file. Returns True on success.\"\"\"\n    config_path = get_config_path()\n    layton_dir = get_layton_dir()\n\n    try:\n        layton_dir.mkdir(parents=True, exist_ok=True)\n        with open(config_path, \"w\") as f:\n            json.dump(config, f, indent=2)\n        return True\n    except OSError:\n        return False\n\n\ndef get_nested(data: dict, key: str) -\u003e Any:\n    \"\"\"Get a value using dot-notation.\n\n    Args:\n        data: The config dictionary\n        key: Dot-notation key (e.g., \"work.schedule.start\")\n\n    Returns:\n        The value at the key path\n\n    Raises:\n        KeyError: If key not found\n    \"\"\"\n    parts = key.split(\".\")\n    current = data\n\n    for part in parts:\n        if isinstance(current, dict) and part in current:\n            current = current[part]\n        else:\n            raise KeyError(f\"Key not found: {key}\")\n\n    return current\n\n\ndef set_nested(data: dict, key: str, value: Any) -\u003e None:\n    \"\"\"Set a value using dot-notation, creating nested dicts as needed.\n\n    Args:\n        data: The config dictionary (modified in place)\n        key: Dot-notation key (e.g., \"work.schedule.start\")\n        value: The value to set\n    \"\"\"\n    parts = key.split(\".\")\n    current = data\n\n    # Navigate/create path to parent\n    for part in parts[:-1]:\n        if part not in current:\n            current[part] = {}\n        elif not isinstance(current[part], dict):\n            # Replace non-dict value with dict\n            current[part] = {}\n        current = current[part]\n\n    # Set the final key\n    current[parts[-1]] = value\n\n\ndef collect_keys(data: dict, prefix: str = \"\") -\u003e list[str]:\n    \"\"\"Collect all dot-notation paths in a nested dict.\n\n    Args:\n        data: The config dictionary\n        prefix: Current path prefix\n\n    Returns:\n        List of all dot-notation paths\n    \"\"\"\n    keys = []\n    for key, value in data.items():\n        full_key = f\"{prefix}.{key}\" if prefix else key\n        if isinstance(value, dict):\n            # Recurse into nested dict\n            keys.extend(collect_keys(value, full_key))\n        else:\n            # Leaf node\n            keys.append(full_key)\n    return keys\n\n\ndef parse_value(value_str: str) -\u003e Any:\n    \"\"\"Parse a value string, attempting JSON if possible.\n\n    Args:\n        value_str: The string value\n\n    Returns:\n        Parsed value (JSON object/array/bool/number) or original string\n    \"\"\"\n    # Try to parse as JSON\n    try:\n        return json.loads(value_str)\n    except json.JSONDecodeError:\n        # Return as string\n        return value_str\n\n\ndef run_config(\n    formatter: OutputFormatter,\n    command: str,\n    key: str | None = None,\n    value: str | None = None,\n    force: bool = False,\n) -\u003e int:\n    \"\"\"Run a config subcommand.\n\n    Args:\n        formatter: Output formatter\n        command: Subcommand (init, show, keys, get, set)\n        key: Key for get/set commands\n        value: Value for set command\n        force: Force overwrite for init\n\n    Returns:\n        Exit code (0=success, 1=error)\n    \"\"\"\n    if command == \"init\":\n        return _config_init(formatter, force)\n    elif command == \"show\":\n        return _config_show(formatter)\n    elif command == \"keys\":\n        return _config_keys(formatter)\n    elif command == \"get\":\n        return _config_get(formatter, key)\n    elif command == \"set\":\n        return _config_set(formatter, key, value)\n    else:\n        formatter.error(\"UNKNOWN_COMMAND\", f\"Unknown config command: {command}\")\n        return 1\n\n\ndef _config_init(formatter: OutputFormatter, force: bool) -\u003e int:\n    \"\"\"Create config with defaults.\"\"\"\n    config_path = get_config_path()\n\n    if config_path.exists() and not force:\n        formatter.error(\n            \"CONFIG_EXISTS\",\n            f\"Config already exists at {config_path}\",\n            next_steps=[\"Use --force to overwrite\"],\n        )\n        return 1\n\n    config = get_default_config()\n    if save_config(config):\n        formatter.success(\n            {\"created\": str(config_path), \"config\": config},\n            next_steps=[\"Run 'layton config show' to view config\"],\n        )\n        return 0\n    else:\n        formatter.error(\n            \"WRITE_FAILED\",\n            f\"Failed to write config to {config_path}\",\n        )\n        return 1\n\n\ndef _config_show(formatter: OutputFormatter) -\u003e int:\n    \"\"\"Display entire config.\"\"\"\n    config = load_config()\n    if config is None:\n        formatter.error(\n            \"CONFIG_MISSING\",\n            \"Config not found. Run 'layton config init' to create it.\",\n            next_steps=[\"layton config init\"],\n        )\n        return 1\n\n    formatter.success({\"config\": config})\n    return 0\n\n\ndef _config_keys(formatter: OutputFormatter) -\u003e int:\n    \"\"\"List all config keys in dot-notation.\"\"\"\n    config = load_config()\n    if config is None:\n        formatter.error(\n            \"CONFIG_MISSING\",\n            \"Config not found. Run 'layton config init' to create it.\",\n            next_steps=[\"layton config init\"],\n        )\n        return 1\n\n    keys = collect_keys(config)\n    formatter.success({\"keys\": sorted(keys)})\n    return 0\n\n\ndef _config_get(formatter: OutputFormatter, key: str | None) -\u003e int:\n    \"\"\"Get a config value.\"\"\"\n    if not key:\n        formatter.error(\"MISSING_KEY\", \"Key is required for 'config get'\")\n        return 1\n\n    config = load_config()\n    if config is None:\n        formatter.error(\n            \"CONFIG_MISSING\",\n            \"Config not found. Run 'layton config init' to create it.\",\n            next_steps=[\"layton config init\"],\n        )\n        return 1\n\n    try:\n        value = get_nested(config, key)\n        formatter.success({\"key\": key, \"value\": value})\n        return 0\n    except KeyError:\n        formatter.error(\n            \"KEY_NOT_FOUND\",\n            f\"Key '{key}' not found in config\",\n            next_steps=[\"Run 'layton config keys' to see available keys\"],\n        )\n        return 1\n\n\ndef _config_set(formatter: OutputFormatter, key: str | None, value: str | None) -\u003e int:\n    \"\"\"Set a config value.\"\"\"\n    if not key:\n        formatter.error(\"MISSING_KEY\", \"Key is required for 'config set'\")\n        return 1\n    if value is None:\n        formatter.error(\"MISSING_VALUE\", \"Value is required for 'config set'\")\n        return 1\n\n    config = load_config()\n    if config is None:\n        formatter.error(\n            \"CONFIG_MISSING\",\n            \"Config not found. Run 'layton config init' to create it.\",\n            next_steps=[\"layton config init\"],\n        )\n        return 1\n\n    # Parse value (JSON if valid, otherwise string)\n    parsed_value = parse_value(value)\n\n    # Set the value\n    set_nested(config, key, parsed_value)\n\n    # Save\n    if save_config(config):\n        formatter.success(\n            {\"key\": key, \"value\": parsed_value, \"config\": config},\n        )\n        return 0\n    else:\n        formatter.error(\"WRITE_FAILED\", \"Failed to write config\")\n        return 1\n```\n\n### CREATE FILE: `tests/layton/unit/test_config.py`\n\n```python\n\"\"\"Unit tests for config module.\"\"\"\nimport json\nimport pytest\nfrom pathlib import Path\n\nfrom laytonlib.config import (\n    get_nested,\n    set_nested,\n    collect_keys,\n    parse_value,\n    get_default_config,\n    load_config,\n    save_config,\n)\n\n\nclass TestGetNested:\n    \"\"\"Tests for dot-notation get.\"\"\"\n\n    def test_flat_key(self):\n        \"\"\"Get flat key.\"\"\"\n        data = {\"timezone\": \"UTC\"}\n        assert get_nested(data, \"timezone\") == \"UTC\"\n\n    def test_nested_key(self):\n        \"\"\"Get nested key.\"\"\"\n        data = {\"work\": {\"schedule\": {\"start\": \"09:00\"}}}\n        assert get_nested(data, \"work.schedule.start\") == \"09:00\"\n\n    def test_get_object(self):\n        \"\"\"Get returns entire object.\"\"\"\n        data = {\"work\": {\"schedule\": {\"start\": \"09:00\", \"end\": \"17:00\"}}}\n        result = get_nested(data, \"work.schedule\")\n        assert result == {\"start\": \"09:00\", \"end\": \"17:00\"}\n\n    def test_missing_key(self):\n        \"\"\"Missing key raises KeyError.\"\"\"\n        data = {\"timezone\": \"UTC\"}\n        with pytest.raises(KeyError):\n            get_nested(data, \"nonexistent\")\n\n    def test_missing_nested_key(self):\n        \"\"\"Missing nested key raises KeyError.\"\"\"\n        data = {\"work\": {}}\n        with pytest.raises(KeyError):\n            get_nested(data, \"work.schedule.start\")\n\n\nclass TestSetNested:\n    \"\"\"Tests for dot-notation set.\"\"\"\n\n    def test_set_flat_key(self):\n        \"\"\"Set flat key.\"\"\"\n        data = {}\n        set_nested(data, \"timezone\", \"UTC\")\n        assert data == {\"timezone\": \"UTC\"}\n\n    def test_set_nested_key(self):\n        \"\"\"Set nested key creates path.\"\"\"\n        data = {}\n        set_nested(data, \"work.schedule.start\", \"09:00\")\n        assert data == {\"work\": {\"schedule\": {\"start\": \"09:00\"}}}\n\n    def test_set_overwrites_existing(self):\n        \"\"\"Set overwrites existing value.\"\"\"\n        data = {\"timezone\": \"UTC\"}\n        set_nested(data, \"timezone\", \"America/Los_Angeles\")\n        assert data[\"timezone\"] == \"America/Los_Angeles\"\n\n    def test_set_adds_to_existing(self):\n        \"\"\"Set adds to existing structure.\"\"\"\n        data = {\"work\": {\"schedule\": {\"start\": \"09:00\"}}}\n        set_nested(data, \"work.schedule.end\", \"17:00\")\n        assert data[\"work\"][\"schedule\"][\"end\"] == \"17:00\"\n\n\nclass TestCollectKeys:\n    \"\"\"Tests for key collection.\"\"\"\n\n    def test_flat_keys(self):\n        \"\"\"Collect flat keys.\"\"\"\n        data = {\"a\": 1, \"b\": 2}\n        keys = collect_keys(data)\n        assert sorted(keys) == [\"a\", \"b\"]\n\n    def test_nested_keys(self):\n        \"\"\"Collect nested keys.\"\"\"\n        data = {\"work\": {\"schedule\": {\"start\": \"09:00\", \"end\": \"17:00\"}}}\n        keys = collect_keys(data)\n        assert sorted(keys) == [\"work.schedule.end\", \"work.schedule.start\"]\n\n    def test_mixed_keys(self):\n        \"\"\"Collect mixed flat and nested keys.\"\"\"\n        data = {\n            \"timezone\": \"UTC\",\n            \"work\": {\"schedule\": {\"start\": \"09:00\"}},\n        }\n        keys = collect_keys(data)\n        assert sorted(keys) == [\"timezone\", \"work.schedule.start\"]\n\n\nclass TestParseValue:\n    \"\"\"Tests for value parsing.\"\"\"\n\n    def test_string(self):\n        \"\"\"Plain string returned as-is.\"\"\"\n        assert parse_value(\"hello\") == \"hello\"\n\n    def test_number(self):\n        \"\"\"JSON number parsed.\"\"\"\n        assert parse_value(\"42\") == 42\n        assert parse_value(\"3.14\") == 3.14\n\n    def test_boolean(self):\n        \"\"\"JSON boolean parsed.\"\"\"\n        assert parse_value(\"true\") is True\n        assert parse_value(\"false\") is False\n\n    def test_object(self):\n        \"\"\"JSON object parsed.\"\"\"\n        result = parse_value('{\"start\": \"09:00\"}')\n        assert result == {\"start\": \"09:00\"}\n\n    def test_array(self):\n        \"\"\"JSON array parsed.\"\"\"\n        result = parse_value('[1, 2, 3]')\n        assert result == [1, 2, 3]\n\n\nclass TestDefaultConfig:\n    \"\"\"Tests for default config.\"\"\"\n\n    def test_has_timezone(self):\n        \"\"\"Default config has timezone.\"\"\"\n        config = get_default_config()\n        assert \"timezone\" in config\n\n    def test_has_work_schedule(self):\n        \"\"\"Default config has work schedule.\"\"\"\n        config = get_default_config()\n        assert config[\"work\"][\"schedule\"][\"start\"] == \"09:00\"\n        assert config[\"work\"][\"schedule\"][\"end\"] == \"17:00\"\n\n\nclass TestLoadSaveConfig:\n    \"\"\"Tests for config persistence.\"\"\"\n\n    def test_load_missing_returns_none(self, isolated_env):\n        \"\"\"Load missing config returns None.\"\"\"\n        config_path = isolated_env / \".layton\" / \"config.json\"\n        if config_path.exists():\n            config_path.unlink()\n\n        result = load_config()\n        assert result is None\n\n    def test_save_and_load(self, isolated_env):\n        \"\"\"Save then load returns same config.\"\"\"\n        config = {\"test\": \"value\"}\n        assert save_config(config) is True\n\n        loaded = load_config()\n        assert loaded == config\n```\n\n### CREATE FILE: `tests/layton/e2e/test_config.py`\n\n```python\n\"\"\"E2E tests for layton config commands.\"\"\"\nimport json\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\n\ndef run_layton(*args, cwd=None):\n    \"\"\"Run layton CLI and return result.\"\"\"\n    script_path = Path(__file__).parent.parent.parent.parent / \"skills\" / \"layton\" / \"scripts\" / \"layton\"\n    result = subprocess.run(\n        [sys.executable, str(script_path), *args],\n        capture_output=True,\n        text=True,\n        cwd=cwd,\n    )\n    return result\n\n\nclass TestConfigInit:\n    \"\"\"E2E tests for config init.\"\"\"\n\n    def test_init_creates_config(self, isolated_env):\n        \"\"\"init creates config file.\"\"\"\n        config_path = isolated_env / \".layton\" / \"config.json\"\n        assert not config_path.exists()\n\n        result = run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        assert result.returncode == 0\n        assert config_path.exists()\n\n        # Verify JSON structure\n        data = json.loads(result.stdout)\n        assert data[\"success\"] is True\n\n    def test_init_fails_if_exists(self, isolated_env):\n        \"\"\"init fails if config exists.\"\"\"\n        config_path = isolated_env / \".layton\" / \"config.json\"\n        config_path.write_text(\"{}\")\n\n        result = run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        assert result.returncode == 1\n        data = json.loads(result.stdout)\n        assert data[\"success\"] is False\n        assert data[\"error\"][\"code\"] == \"CONFIG_EXISTS\"\n\n    def test_init_force_overwrites(self, isolated_env):\n        \"\"\"init --force overwrites existing.\"\"\"\n        config_path = isolated_env / \".layton\" / \"config.json\"\n        config_path.write_text('{\"old\": \"value\"}')\n\n        result = run_layton(\"config\", \"init\", \"--force\", cwd=isolated_env)\n\n        assert result.returncode == 0\n\n        # Verify new config has defaults\n        config = json.loads(config_path.read_text())\n        assert \"timezone\" in config\n\n\nclass TestConfigShow:\n    \"\"\"E2E tests for config show.\"\"\"\n\n    def test_show_displays_config(self, isolated_env):\n        \"\"\"show displays config content.\"\"\"\n        # Create config first\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"config\", \"show\", cwd=isolated_env)\n\n        assert result.returncode == 0\n        data = json.loads(result.stdout)\n        assert data[\"success\"] is True\n        assert \"config\" in data[\"data\"]\n\n    def test_show_fails_if_missing(self, isolated_env):\n        \"\"\"show fails if no config.\"\"\"\n        result = run_layton(\"config\", \"show\", cwd=isolated_env)\n\n        assert result.returncode == 1\n        data = json.loads(result.stdout)\n        assert data[\"error\"][\"code\"] == \"CONFIG_MISSING\"\n\n    def test_config_no_subcommand_runs_show(self, isolated_env):\n        \"\"\"config with no subcommand runs show.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"config\", cwd=isolated_env)\n\n        assert result.returncode == 0\n        data = json.loads(result.stdout)\n        assert \"config\" in data[\"data\"]\n\n\nclass TestConfigKeys:\n    \"\"\"E2E tests for config keys.\"\"\"\n\n    def test_keys_lists_paths(self, isolated_env):\n        \"\"\"keys lists all dot-notation paths.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"config\", \"keys\", cwd=isolated_env)\n\n        assert result.returncode == 0\n        data = json.loads(result.stdout)\n        keys = data[\"data\"][\"keys\"]\n        assert \"timezone\" in keys\n        assert \"work.schedule.start\" in keys\n\n\nclass TestConfigGet:\n    \"\"\"E2E tests for config get.\"\"\"\n\n    def test_get_flat_key(self, isolated_env):\n        \"\"\"get retrieves flat key.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"config\", \"get\", \"timezone\", cwd=isolated_env)\n\n        assert result.returncode == 0\n        data = json.loads(result.stdout)\n        assert data[\"data\"][\"key\"] == \"timezone\"\n\n    def test_get_nested_key(self, isolated_env):\n        \"\"\"get retrieves nested key.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"config\", \"get\", \"work.schedule.start\", cwd=isolated_env)\n\n        assert result.returncode == 0\n        data = json.loads(result.stdout)\n        assert data[\"data\"][\"value\"] == \"09:00\"\n\n    def test_get_missing_key(self, isolated_env):\n        \"\"\"get fails for missing key.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"config\", \"get\", \"nonexistent\", cwd=isolated_env)\n\n        assert result.returncode == 1\n        data = json.loads(result.stdout)\n        assert data[\"error\"][\"code\"] == \"KEY_NOT_FOUND\"\n\n\nclass TestConfigSet:\n    \"\"\"E2E tests for config set.\"\"\"\n\n    def test_set_updates_value(self, isolated_env):\n        \"\"\"set updates existing value.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"config\", \"set\", \"timezone\", \"Europe/London\", cwd=isolated_env)\n\n        assert result.returncode == 0\n\n        # Verify change\n        result = run_layton(\"config\", \"get\", \"timezone\", cwd=isolated_env)\n        data = json.loads(result.stdout)\n        assert data[\"data\"][\"value\"] == \"Europe/London\"\n\n    def test_set_creates_nested_path(self, isolated_env):\n        \"\"\"set creates nested path.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"config\", \"set\", \"custom.nested.key\", \"value\", cwd=isolated_env)\n\n        assert result.returncode == 0\n\n        # Verify\n        result = run_layton(\"config\", \"get\", \"custom.nested.key\", cwd=isolated_env)\n        data = json.loads(result.stdout)\n        assert data[\"data\"][\"value\"] == \"value\"\n\n    def test_set_parses_json(self, isolated_env):\n        \"\"\"set parses JSON values.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\n            \"config\", \"set\", \"work.schedule\",\n            '{\"start\": \"08:00\", \"end\": \"16:00\"}',\n            cwd=isolated_env\n        )\n\n        assert result.returncode == 0\n\n        # Verify\n        result = run_layton(\"config\", \"get\", \"work.schedule.start\", cwd=isolated_env)\n        data = json.loads(result.stdout)\n        assert data[\"data\"][\"value\"] == \"08:00\"\n```\n\n## Exit Criteria\n\n```bash\n# Config init works\n./skills/layton/scripts/layton config init\n\n# Config show works\n./skills/layton/scripts/layton config show\n\n# Config keys works\n./skills/layton/scripts/layton config keys\n\n# Config get/set work\n./skills/layton/scripts/layton config get timezone\n./skills/layton/scripts/layton config set timezone \"America/New_York\"\n./skills/layton/scripts/layton config get work.schedule.start\n\n# Unit tests pass\nuv run pytest tests/layton/unit/test_config.py -v\n\n# E2E tests pass\nuv run pytest tests/layton/e2e/test_config.py -v\n```\n\n### Checklist\n- [ ] `config init` creates config with defaults\n- [ ] `config init --force` overwrites existing\n- [ ] `config show` dumps entire config (default subcommand)\n- [ ] `config keys` lists dot-notation paths\n- [ ] `config get \u003ckey\u003e` retrieves value with dot-notation\n- [ ] `config set \u003ckey\u003e \u003cvalue\u003e` updates value, parses JSON\n- [ ] Missing config returns CONFIG_MISSING error\n- [ ] Missing key returns KEY_NOT_FOUND error\n- [ ] Git root detection works\n\n## Files to Modify\n\n- `skills/layton/laytonlib/config.py` (REPLACE) - Full implementation\n- `tests/layton/unit/test_config.py` (CREATE) - Unit tests\n- `tests/layton/e2e/test_config.py` (CREATE) - E2E tests","status":"closed","priority":1,"issue_type":"task","owner":"hild@b4mad.net","created_at":"2026-01-15T17:16:44.457803+01:00","created_by":"Marcel Hild","updated_at":"2026-01-15T17:57:16.610553+01:00","closed_at":"2026-01-15T17:57:16.610553+01:00","close_reason":"Done: Implemented config commands with dot-notation access, init/show/keys/get/set, and full test coverage","labels":["openspec:layton-stage0-foundation"],"dependencies":[{"issue_id":"durandom-42q.4","depends_on_id":"durandom-42q","type":"parent-child","created_at":"2026-01-15T17:16:44.461026+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.4","depends_on_id":"durandom-42q.2","type":"blocks","created_at":"2026-01-15T17:19:05.931057+01:00","created_by":"Marcel Hild"}]}
{"id":"durandom-42q.5","title":"Context Command - Temporal context with time-of-day classification","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/layton-stage0-foundation/specs/cli-context/spec.md\n**Task**: 5.1-5.9 from tasks.md\n\n## Requirements\n\nImplement `layton context` command for temporal context.\n\n**From cli-context spec:**\n\n1. **Output fields**:\n   - `timestamp`: ISO 8601 datetime\n   - `time_of_day`: Classification string\n   - `day_of_week`: Day name (e.g., \"Monday\")\n   - `work_hours`: Boolean (within work schedule)\n   - `timezone`: From config\n\n2. **Time of day classification**:\n   - `morning`: 05:00-11:59\n   - `midday`: 12:00-13:59\n   - `afternoon`: 14:00-17:59\n   - `evening`: 18:00-21:59\n   - `night`: 22:00-04:59\n\n3. **Work hours calculation**:\n   - Uses `work.schedule.start` and `work.schedule.end` from config\n   - Inclusive at boundaries\n   - Returns boolean\n\n4. **Config dependency**:\n   - Requires valid config with `timezone` and `work.schedule`\n   - Returns `CONFIG_MISSING` error if missing\n\n5. **Human output**:\n   - Natural language summary\n   - Example: \"It's Monday morning, within work hours\"\n\n## Reference Implementation\n\n### REPLACE FILE: `skills/layton/laytonlib/context.py`\n\n```python\n\"\"\"Temporal context for Layton.\n\nProvides deterministic temporal information: time of day, work hours, day of week.\nAll calculations are based on the timezone in config.\n\"\"\"\nfrom datetime import datetime, time\nfrom typing import Literal\nfrom zoneinfo import ZoneInfo\n\nfrom laytonlib.config import load_config, get_nested\nfrom laytonlib.formatters import OutputFormatter\n\n\nTimeOfDay = Literal[\"morning\", \"midday\", \"afternoon\", \"evening\", \"night\"]\n\n\ndef classify_time_of_day(hour: int) -\u003e TimeOfDay:\n    \"\"\"Classify the hour into a time of day period.\n\n    Args:\n        hour: Hour in 24-hour format (0-23)\n\n    Returns:\n        Time of day classification\n    \"\"\"\n    if 5 \u003c= hour \u003c= 11:\n        return \"morning\"\n    elif 12 \u003c= hour \u003c= 13:\n        return \"midday\"\n    elif 14 \u003c= hour \u003c= 17:\n        return \"afternoon\"\n    elif 18 \u003c= hour \u003c= 21:\n        return \"evening\"\n    else:  # 22-23 or 0-4\n        return \"night\"\n\n\ndef parse_time(time_str: str) -\u003e time:\n    \"\"\"Parse a time string (HH:MM) into a time object.\n\n    Args:\n        time_str: Time in HH:MM format\n\n    Returns:\n        time object\n    \"\"\"\n    parts = time_str.split(\":\")\n    return time(int(parts[0]), int(parts[1]))\n\n\ndef is_within_work_hours(\n    current_time: time,\n    work_start: str,\n    work_end: str,\n) -\u003e bool:\n    \"\"\"Check if current time is within work hours (inclusive).\n\n    Args:\n        current_time: Current time\n        work_start: Work start time (HH:MM)\n        work_end: Work end time (HH:MM)\n\n    Returns:\n        True if within work hours\n    \"\"\"\n    start = parse_time(work_start)\n    end = parse_time(work_end)\n\n    # Simple comparison (assumes start \u003c end, no overnight)\n    return start \u003c= current_time \u003c= end\n\n\ndef get_temporal_context(timezone_str: str, work_start: str, work_end: str) -\u003e dict:\n    \"\"\"Get full temporal context.\n\n    Args:\n        timezone_str: Timezone string (e.g., \"America/Los_Angeles\")\n        work_start: Work start time (HH:MM)\n        work_end: Work end time (HH:MM)\n\n    Returns:\n        Dict with temporal context fields\n    \"\"\"\n    # Get current time in configured timezone\n    try:\n        tz = ZoneInfo(timezone_str)\n    except Exception:\n        # Fallback to UTC if timezone invalid\n        tz = ZoneInfo(\"UTC\")\n\n    now = datetime.now(tz)\n\n    return {\n        \"timestamp\": now.isoformat(),\n        \"time_of_day\": classify_time_of_day(now.hour),\n        \"day_of_week\": now.strftime(\"%A\"),\n        \"work_hours\": is_within_work_hours(now.time(), work_start, work_end),\n        \"timezone\": timezone_str,\n    }\n\n\ndef format_human_context(context: dict) -\u003e str:\n    \"\"\"Format context as human-readable summary.\n\n    Args:\n        context: Temporal context dict\n\n    Returns:\n        Human-readable summary string\n    \"\"\"\n    day = context[\"day_of_week\"]\n    tod = context[\"time_of_day\"]\n    work = \"within work hours\" if context[\"work_hours\"] else \"outside work hours\"\n\n    return f\"It's {day} {tod}, {work}.\"\n\n\ndef run_context(formatter: OutputFormatter) -\u003e int:\n    \"\"\"Run the context command.\n\n    Args:\n        formatter: Output formatter\n\n    Returns:\n        Exit code (0=success, 1=error)\n    \"\"\"\n    # Load config\n    config = load_config()\n    if config is None:\n        formatter.error(\n            \"CONFIG_MISSING\",\n            \"Config not found. Run 'layton config init' to create it.\",\n            next_steps=[\"layton config init\"],\n        )\n        return 1\n\n    # Get required config values\n    try:\n        timezone = get_nested(config, \"timezone\")\n    except KeyError:\n        formatter.error(\n            \"CONFIG_MISSING\",\n            \"Config key 'timezone' not found.\",\n            next_steps=[\n                \"Run 'layton config init --force' to reset config\",\n                \"Or run 'layton config set timezone \\\"UTC\\\"'\",\n            ],\n        )\n        return 1\n\n    try:\n        work_start = get_nested(config, \"work.schedule.start\")\n        work_end = get_nested(config, \"work.schedule.end\")\n    except KeyError:\n        formatter.error(\n            \"CONFIG_MISSING\",\n            \"Config key 'work.schedule.start' or 'work.schedule.end' not found.\",\n            next_steps=[\n                \"Run 'layton config init --force' to reset config\",\n                \"Or run 'layton config set work.schedule.start \\\"09:00\\\"'\",\n            ],\n        )\n        return 1\n\n    # Get temporal context\n    context = get_temporal_context(timezone, work_start, work_end)\n\n    # Output\n    if formatter.human:\n        # Add human-readable summary\n        context[\"summary\"] = format_human_context(context)\n\n    formatter.success(context)\n    return 0\n```\n\n### CREATE FILE: `tests/layton/unit/test_context.py`\n\n```python\n\"\"\"Unit tests for context module.\"\"\"\nfrom datetime import time\n\nimport pytest\n\nfrom laytonlib.context import (\n    classify_time_of_day,\n    parse_time,\n    is_within_work_hours,\n    format_human_context,\n)\n\n\nclass TestClassifyTimeOfDay:\n    \"\"\"Tests for time of day classification.\"\"\"\n\n    @pytest.mark.parametrize(\"hour,expected\", [\n        (5, \"morning\"),\n        (6, \"morning\"),\n        (11, \"morning\"),\n        (12, \"midday\"),\n        (13, \"midday\"),\n        (14, \"afternoon\"),\n        (17, \"afternoon\"),\n        (18, \"evening\"),\n        (21, \"evening\"),\n        (22, \"night\"),\n        (23, \"night\"),\n        (0, \"night\"),\n        (4, \"night\"),\n    ])\n    def test_classification(self, hour: int, expected: str):\n        \"\"\"Test all time boundaries.\"\"\"\n        assert classify_time_of_day(hour) == expected\n\n\nclass TestParseTime:\n    \"\"\"Tests for time parsing.\"\"\"\n\n    def test_parse_simple(self):\n        \"\"\"Parse simple time.\"\"\"\n        result = parse_time(\"09:00\")\n        assert result == time(9, 0)\n\n    def test_parse_with_minutes(self):\n        \"\"\"Parse time with minutes.\"\"\"\n        result = parse_time(\"17:30\")\n        assert result == time(17, 30)\n\n\nclass TestIsWithinWorkHours:\n    \"\"\"Tests for work hours calculation.\"\"\"\n\n    def test_within_hours(self):\n        \"\"\"Time within work hours.\"\"\"\n        current = time(10, 30)\n        assert is_within_work_hours(current, \"09:00\", \"17:00\") is True\n\n    def test_at_start_boundary(self):\n        \"\"\"Time exactly at start is within.\"\"\"\n        current = time(9, 0)\n        assert is_within_work_hours(current, \"09:00\", \"17:00\") is True\n\n    def test_at_end_boundary(self):\n        \"\"\"Time exactly at end is within.\"\"\"\n        current = time(17, 0)\n        assert is_within_work_hours(current, \"09:00\", \"17:00\") is True\n\n    def test_before_start(self):\n        \"\"\"Time before start is outside.\"\"\"\n        current = time(8, 59)\n        assert is_within_work_hours(current, \"09:00\", \"17:00\") is False\n\n    def test_after_end(self):\n        \"\"\"Time after end is outside.\"\"\"\n        current = time(17, 1)\n        assert is_within_work_hours(current, \"09:00\", \"17:00\") is False\n\n\nclass TestFormatHumanContext:\n    \"\"\"Tests for human-readable formatting.\"\"\"\n\n    def test_work_hours(self):\n        \"\"\"Format during work hours.\"\"\"\n        context = {\n            \"day_of_week\": \"Monday\",\n            \"time_of_day\": \"morning\",\n            \"work_hours\": True,\n        }\n        result = format_human_context(context)\n        assert \"Monday morning\" in result\n        assert \"within work hours\" in result\n\n    def test_outside_work_hours(self):\n        \"\"\"Format outside work hours.\"\"\"\n        context = {\n            \"day_of_week\": \"Saturday\",\n            \"time_of_day\": \"evening\",\n            \"work_hours\": False,\n        }\n        result = format_human_context(context)\n        assert \"Saturday evening\" in result\n        assert \"outside work hours\" in result\n```\n\n### CREATE FILE: `tests/layton/e2e/test_context.py`\n\n```python\n\"\"\"E2E tests for layton context command.\"\"\"\nimport json\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\n\ndef run_layton(*args, cwd=None):\n    \"\"\"Run layton CLI and return result.\"\"\"\n    script_path = Path(__file__).parent.parent.parent.parent / \"skills\" / \"layton\" / \"scripts\" / \"layton\"\n    result = subprocess.run(\n        [sys.executable, str(script_path), *args],\n        capture_output=True,\n        text=True,\n        cwd=cwd,\n    )\n    return result\n\n\nclass TestContextCommand:\n    \"\"\"E2E tests for layton context.\"\"\"\n\n    def test_context_requires_config(self, isolated_env):\n        \"\"\"context fails if no config.\"\"\"\n        result = run_layton(\"context\", cwd=isolated_env)\n\n        assert result.returncode == 1\n        data = json.loads(result.stdout)\n        assert data[\"error\"][\"code\"] == \"CONFIG_MISSING\"\n\n    def test_context_outputs_json(self, isolated_env):\n        \"\"\"context outputs valid JSON with config.\"\"\"\n        # Create config\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"context\", cwd=isolated_env)\n\n        assert result.returncode == 0\n        data = json.loads(result.stdout)\n        assert data[\"success\"] is True\n\n        # Check required fields\n        context = data[\"data\"]\n        assert \"timestamp\" in context\n        assert \"time_of_day\" in context\n        assert \"day_of_week\" in context\n        assert \"work_hours\" in context\n        assert \"timezone\" in context\n\n    def test_context_time_of_day_valid(self, isolated_env):\n        \"\"\"context returns valid time_of_day.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"context\", cwd=isolated_env)\n\n        data = json.loads(result.stdout)\n        tod = data[\"data\"][\"time_of_day\"]\n        assert tod in [\"morning\", \"midday\", \"afternoon\", \"evening\", \"night\"]\n\n    def test_context_human_output(self, isolated_env):\n        \"\"\"context --human includes summary.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n\n        result = run_layton(\"context\", \"--human\", cwd=isolated_env)\n\n        # Human output should include day and time of day\n        assert result.returncode == 0\n        # Human output is not JSON, should have readable text\n        output = result.stdout\n        # Should mention day of week somewhere\n        days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n        assert any(day in output for day in days)\n\n    def test_context_respects_timezone(self, isolated_env):\n        \"\"\"context uses timezone from config.\"\"\"\n        run_layton(\"config\", \"init\", cwd=isolated_env)\n        run_layton(\"config\", \"set\", \"timezone\", \"America/Los_Angeles\", cwd=isolated_env)\n\n        result = run_layton(\"context\", cwd=isolated_env)\n\n        data = json.loads(result.stdout)\n        assert data[\"data\"][\"timezone\"] == \"America/Los_Angeles\"\n```\n\n## Exit Criteria\n\n```bash\n# Context requires config\n./skills/layton/scripts/layton context  # Should fail without config\n\n# Context works with config\n./skills/layton/scripts/layton config init\n./skills/layton/scripts/layton context\n\n# JSON output has required fields\n./skills/layton/scripts/layton context | jq '.data.time_of_day'\n./skills/layton/scripts/layton context | jq '.data.work_hours'\n\n# Human output\n./skills/layton/scripts/layton context --human\n\n# Unit tests pass\nuv run pytest tests/layton/unit/test_context.py -v\n\n# E2E tests pass\nuv run pytest tests/layton/e2e/test_context.py -v\n```\n\n### Checklist\n- [ ] Output includes timestamp (ISO 8601), time_of_day, day_of_week, work_hours, timezone\n- [ ] Time of day classified correctly: morning (5-11), midday (12-13), afternoon (14-17), evening (18-21), night (22-4)\n- [ ] Work hours calculated from config (inclusive boundaries)\n- [ ] Uses timezone from config\n- [ ] Returns CONFIG_MISSING if config missing or keys missing\n- [ ] Human output includes natural language summary\n- [ ] Unit tests cover classification boundaries\n- [ ] E2E tests verify CLI behavior\n\n## Files to Modify\n\n- `skills/layton/laytonlib/context.py` (REPLACE) - Full implementation\n- `tests/layton/unit/test_context.py` (CREATE) - Unit tests\n- `tests/layton/e2e/test_context.py` (CREATE) - E2E tests","status":"closed","priority":1,"issue_type":"task","owner":"hild@b4mad.net","created_at":"2026-01-15T17:17:38.203361+01:00","created_by":"Marcel Hild","updated_at":"2026-01-15T17:58:36.465969+01:00","closed_at":"2026-01-15T17:58:36.465969+01:00","close_reason":"Done: Implemented context command with time-of-day classification, work hours, timezone support, and full test coverage","labels":["openspec:layton-stage0-foundation"],"dependencies":[{"issue_id":"durandom-42q.5","depends_on_id":"durandom-42q","type":"parent-child","created_at":"2026-01-15T17:17:38.204552+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.5","depends_on_id":"durandom-42q.4","type":"blocks","created_at":"2026-01-15T17:19:06.888623+01:00","created_by":"Marcel Hild"}]}
{"id":"durandom-42q.6","title":"SKILL.md and Workflows - Router pattern with workflow and reference files","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/layton-stage0-foundation/specs/beads-conventions/spec.md\n**Task**: 6.1-6.6 from tasks.md\n\n## Requirements\n\nCreate SKILL.md using Router Pattern with workflows and references directories.\n\n**From beads-conventions spec:**\n\n1. **Directory structure (Router Pattern)**:\n```\nskills/layton/\n├── SKILL.md              # Router + essential principles (under 500 lines)\n├── workflows/            # Step-by-step procedures (FOLLOW)\n│   ├── morning-briefing.md\n│   ├── track-item.md\n│   └── set-focus.md\n├── references/           # Domain knowledge (READ on-demand)\n│   ├── beads-commands.md\n│   └── persona.md\n└── scripts/              # Executable code (RUN)\n    └── layton\n```\n\n2. **SKILL.md uses pure XML structure**:\n   - Required tags: `\u003cobjective\u003e`, `\u003cquick_start\u003e`, `\u003csuccess_criteria\u003e`\n   - YAML frontmatter for name/description\n\n3. **Beads label conventions**:\n   - `layton`: namespace label on all Layton beads\n   - `watching`: items user wants tracked\n   - `focus`: current work item (only one at a time)\n\n4. **bd commands are LOW FREEDOM**:\n   - Exact syntax in workflows (not vague \"use bd to...\")\n   - Always include `--json` flag\n   - Always include `layton` label\n\n## Reference Implementation\n\n### REPLACE FILE: `skills/layton/SKILL.md`\n\n```markdown\n---\nname: layton\ndescription: Personal AI assistant for attention management. Use when user asks about focus, briefings, or tracking items across systems.\n---\n\n\u003cobjective\u003e\nLayton is your personal secretary—managing attention, synthesizing information from multiple systems, and providing context-aware briefings.\n\nStage 0 provides: health checks (doctor), temporal context, and configuration management.\n\u003c/objective\u003e\n\n\u003cquick_start\u003e\n**Morning briefing**: Run workflow in `workflows/morning-briefing.md`\n**Track something**: Run workflow in `workflows/track-item.md`\n**Set focus**: Run workflow in `workflows/set-focus.md`\n\nFor bd command details, see `references/beads-commands.md`.\n\u003c/quick_start\u003e\n\n\u003cprinciples\u003e\n- Use `bd` directly for all state operations (never wrap it)\n- Always include `--json` flag for machine-readable output\n- Always include `layton` label on beads Layton creates\n- Only ONE bead should have `focus` label at any time\n\u003c/principles\u003e\n\n\u003ccli_commands\u003e\n**Health check:**\n```bash\nlayton doctor\n```\n\n**Temporal context:**\n```bash\nlayton context\n```\nOutput: timestamp, time_of_day, day_of_week, work_hours, timezone\n\n**Configuration:**\n```bash\nlayton config show    # Display config\nlayton config init    # Create default config\nlayton config get \u003ckey\u003e\nlayton config set \u003ckey\u003e \u003cvalue\u003e\n```\n\u003c/cli_commands\u003e\n\n\u003csuccess_criteria\u003e\n- [ ] User knows what they're tracking (bd list --label watching)\n- [ ] User knows their current focus (bd list --label focus)\n- [ ] Briefings adapt to time of day and workload\n\u003c/success_criteria\u003e\n```\n\n### CREATE FILE: `skills/layton/workflows/morning-briefing.md`\n\n```markdown\n\u003cworkflow name=\"morning-briefing\"\u003e\n\u003cobjective\u003eProvide context-aware status update.\u003c/objective\u003e\n\n\u003csteps\u003e\n1. Get temporal context:\n   ```bash\n   layton context\n   ```\n\n2. Get attention items:\n   ```bash\n   bd list --label watching --json\n   ```\n\n3. Get current focus:\n   ```bash\n   bd list --label focus --json\n   ```\n\n4. Synthesize briefing using persona voice (see `references/persona.md`)\n\u003c/steps\u003e\n\n\u003csynthesis_rules\u003e\nOrder of presentation:\n1. Current focus (if any) — \"You're working on...\"\n2. Attention items sorted by priority — \"Watching N items...\"\n3. Time-appropriate suggestions — based on `time_of_day`\n\nContext adaptation:\n- `morning` + `work_hours: true` → full briefing\n- `evening` + `work_hours: false` → brief summary only\n- attention count \u003e 5 → suggest triage\n\u003c/synthesis_rules\u003e\n\n\u003csuccess_criteria\u003e\n- [ ] Briefing adapts to time of day\n- [ ] Focus item mentioned first (if exists)\n- [ ] Attention items summarized with counts\n\u003c/success_criteria\u003e\n\u003c/workflow\u003e\n```\n\n### CREATE FILE: `skills/layton/workflows/track-item.md`\n\n```markdown\n\u003cworkflow name=\"track-item\"\u003e\n\u003cobjective\u003eAdd an item to Layton's attention list.\u003c/objective\u003e\n\n\u003csteps\u003e\n1. Parse user request for: item ID, source system, context\n\n2. Create bead:\n   ```bash\n   bd create \"\u003cID\u003e: \u003ccontext\u003e\" -t task -p 2 -l watching,\u003csource\u003e,layton --json\n   ```\n   \n   Where:\n   - `\u003cID\u003e`: External identifier (e.g., JIRA-1234, PR-847)\n   - `\u003ccontext\u003e`: User-provided context (e.g., \"blocking release\")\n   - `\u003csource\u003e`: Source system label (e.g., jira, github)\n\n3. Confirm to user with bead ID for future reference\n\u003c/steps\u003e\n\n\u003cexamples\u003e\nUser: \"Track JIRA-1234, it's blocking the release\"\n```bash\nbd create \"JIRA-1234: blocking release\" -t task -p 2 -l watching,jira,layton --json\n```\n\nUser: \"Keep an eye on PR 847\"\n```bash\nbd create \"PR-847: user wants to monitor\" -t task -p 2 -l watching,github,layton --json\n```\n\u003c/examples\u003e\n\n\u003csuccess_criteria\u003e\n- [ ] Bead created with `watching` and `layton` labels\n- [ ] User received confirmation with bead ID\n\u003c/success_criteria\u003e\n\u003c/workflow\u003e\n```\n\n### CREATE FILE: `skills/layton/workflows/set-focus.md`\n\n```markdown\n\u003cworkflow name=\"set-focus\"\u003e\n\u003cobjective\u003eSet current focus (only one at a time).\u003c/objective\u003e\n\n\u003csteps\u003e\n1. Check existing focus:\n   ```bash\n   bd list --label focus --json\n   ```\n\n2. If focus exists, remove label:\n   ```bash\n   bd update \u003cold-id\u003e --remove-label focus --json\n   ```\n\n3. Set new focus:\n   - For existing bead:\n     ```bash\n     bd update \u003cid\u003e --add-label focus --json\n     ```\n   - For new item:\n     ```bash\n     bd create \"\u003cdescription\u003e\" -t task -p 2 -l focus,layton --json\n     ```\n\u003c/steps\u003e\n\n\u003cconstraint\u003e\nCRITICAL: Only ONE bead should have `focus` label at any time.\nAlways remove focus from previous item before setting new focus.\n\u003c/constraint\u003e\n\n\u003csuccess_criteria\u003e\n- [ ] Only ONE bead has `focus` label\n- [ ] Previous focus label removed (if any)\n\u003c/success_criteria\u003e\n\u003c/workflow\u003e\n```\n\n### CREATE FILE: `skills/layton/references/beads-commands.md`\n\n```markdown\n# Beads Command Reference\n\n## Creating beads\n\n**Track external item:**\n```bash\nbd create \"JIRA-1234: blocking release\" -t task -p 2 -l watching,jira,layton --json\n```\n\nOutput:\n```json\n{\"id\": \"beads-abc\", \"title\": \"JIRA-1234: blocking release\", \"labels\": [\"watching\", \"jira\", \"layton\"]}\n```\n\n## Querying beads\n\n| Query | Command |\n|-------|---------|\n| Watched items | `bd list --label watching --json` |\n| Current focus | `bd list --label focus --json` |\n| All Layton beads | `bd list --label layton --json` |\n| Ready work | `bd ready --json` |\n\n## Updating beads\n\n**Add label:**\n```bash\nbd update \u003cid\u003e --add-label \u003clabel\u003e --json\n```\n\n**Remove label:**\n```bash\nbd update \u003cid\u003e --remove-label \u003clabel\u003e --json\n```\n\n## Closing beads\n\n```bash\nbd close \u003cid\u003e --reason \"...\" --json\n```\n\n## Label conventions\n\n| Label | Purpose |\n|-------|---------|\n| `layton` | Namespace - all Layton-managed beads |\n| `watching` | Items user wants tracked |\n| `focus` | Current work item (only one) |\n| `jira`, `github`, etc. | Source system |\n```\n\n### CREATE FILE: `skills/layton/references/persona.md`\n\n```markdown\n# Layton Persona\n\n\u003c!-- Placeholder for Stage 1 --\u003e\n\nLayton is named after Elizabeth Layton (later Elizabeth Nel), Winston Churchill's wartime secretary.\n\n## Voice characteristics\n\n- Professional but warm\n- Concise, respects user's time\n- Proactive about surfacing important items\n- Adapts tone to time of day\n\n## Stage 1 additions\n\nThis file will be expanded in Stage 1 to include:\n- Detailed persona guidelines\n- Tone examples for different contexts\n- Briefing templates\n```\n\n### CREATE DIRECTORIES\n\n```bash\nmkdir -p skills/layton/workflows\nmkdir -p skills/layton/references\n```\n\n## Exit Criteria\n\n```bash\n# Directory structure exists\nls skills/layton/SKILL.md\nls skills/layton/workflows/\nls skills/layton/references/\n\n# SKILL.md has required structure\ngrep -q '\u003cobjective\u003e' skills/layton/SKILL.md\ngrep -q '\u003cquick_start\u003e' skills/layton/SKILL.md\ngrep -q '\u003csuccess_criteria\u003e' skills/layton/SKILL.md\n\n# Workflows exist\nls skills/layton/workflows/morning-briefing.md\nls skills/layton/workflows/track-item.md\nls skills/layton/workflows/set-focus.md\n\n# References exist\nls skills/layton/references/beads-commands.md\nls skills/layton/references/persona.md\n```\n\n### Checklist\n- [ ] SKILL.md has YAML frontmatter with name and description\n- [ ] SKILL.md uses pure XML structure (`\u003cobjective\u003e`, `\u003cquick_start\u003e`, `\u003csuccess_criteria\u003e`)\n- [ ] SKILL.md routes to workflows/ and references/\n- [ ] workflows/morning-briefing.md has synthesis rules\n- [ ] workflows/track-item.md has exact bd create command\n- [ ] workflows/set-focus.md enforces single-focus constraint\n- [ ] references/beads-commands.md has query table\n- [ ] references/persona.md is placeholder for Stage 1\n\n## Files to Create\n\n- `skills/layton/SKILL.md` (REPLACE) - Full router skill\n- `skills/layton/workflows/morning-briefing.md` (CREATE) - Briefing workflow\n- `skills/layton/workflows/track-item.md` (CREATE) - Track workflow\n- `skills/layton/workflows/set-focus.md` (CREATE) - Focus workflow\n- `skills/layton/references/beads-commands.md` (CREATE) - Command reference\n- `skills/layton/references/persona.md` (CREATE) - Persona placeholder","status":"closed","priority":1,"issue_type":"task","owner":"hild@b4mad.net","created_at":"2026-01-15T17:18:32.546948+01:00","created_by":"Marcel Hild","updated_at":"2026-01-15T17:59:34.039959+01:00","closed_at":"2026-01-15T17:59:34.039959+01:00","close_reason":"Done: Created SKILL.md router, 3 workflows (morning-briefing, track-item, set-focus), and 2 references (beads-commands, persona)","labels":["openspec:layton-stage0-foundation"],"dependencies":[{"issue_id":"durandom-42q.6","depends_on_id":"durandom-42q","type":"parent-child","created_at":"2026-01-15T17:18:32.548208+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.6","depends_on_id":"durandom-42q.1","type":"blocks","created_at":"2026-01-15T17:19:08.153699+01:00","created_by":"Marcel Hild"}]}
{"id":"durandom-42q.7","title":"Integration \u0026 Documentation - Test suite and manual verification","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/layton-stage0-foundation/tasks.md\n**Task**: 7.1-7.3 from tasks.md\n\n## Requirements\n\nRun full test suite, manual testing, and verify Beads integration.\n\n**From tasks.md:**\n\n1. **Run full test suite** - All unit and e2e tests pass\n2. **Manual CLI testing** - Test in isolated environment\n3. **Verify Beads integration** - Test with real `bd` CLI\n\n## Reference Implementation\n\n### Test Commands\n\n```bash\n# Run all Layton tests\nuv run pytest tests/layton/ -v\n\n# Run with coverage\nuv run pytest tests/layton/ --cov=skills/layton/laytonlib --cov-report=term-missing\n\n# Run only unit tests\nuv run pytest tests/layton/unit/ -v\n\n# Run only e2e tests\nuv run pytest tests/layton/e2e/ -v\n```\n\n### Manual Testing Script\n\nCreate a temporary directory and test CLI:\n\n```bash\n#!/bin/bash\n# Manual test script for Layton CLI\n\nset -e\n\n# Create temp directory\nTEMP_DIR=$(mktemp -d)\ncd \"$TEMP_DIR\"\n\n# Initialize git repo (for git root detection)\ngit init\n\necho \"=== Testing layton doctor ===\"\n../../skills/layton/scripts/layton doctor || echo \"Expected to fail (no config)\"\n\necho \"\"\necho \"=== Testing layton config init ===\"\n../../skills/layton/scripts/layton config init\n\necho \"\"\necho \"=== Testing layton config show ===\"\n../../skills/layton/scripts/layton config show\n\necho \"\"\necho \"=== Testing layton config keys ===\"\n../../skills/layton/scripts/layton config keys\n\necho \"\"\necho \"=== Testing layton config get ===\"\n../../skills/layton/scripts/layton config get timezone\n../../skills/layton/scripts/layton config get work.schedule.start\n\necho \"\"\necho \"=== Testing layton config set ===\"\n../../skills/layton/scripts/layton config set timezone \"America/New_York\"\n../../skills/layton/scripts/layton config get timezone\n\necho \"\"\necho \"=== Testing layton context ===\"\n../../skills/layton/scripts/layton context\n\necho \"\"\necho \"=== Testing layton context --human ===\"\n../../skills/layton/scripts/layton context --human\n\necho \"\"\necho \"=== Testing layton doctor (should pass now) ===\"\n../../skills/layton/scripts/layton doctor\n\necho \"\"\necho \"=== Testing no-arg defaults ===\"\n../../skills/layton/scripts/layton  # Should run doctor\n\necho \"\"\necho \"=== All manual tests passed! ===\"\n\n# Cleanup\ncd -\nrm -rf \"$TEMP_DIR\"\n```\n\n### Beads Integration Verification\n\n```bash\n# Verify bd CLI is available\nbd --version\n\n# Verify bd info works\nbd info --json\n\n# Test creating a bead (in isolated env)\ncd $(mktemp -d)\ngit init\nbd init\nbd create \"Test bead\" -t task -p 2 -l watching,layton --json\nbd list --label layton --json\ncd -\n```\n\n### Lint and Format\n\n```bash\n# Run linter on Layton code\nuv run ruff check skills/layton/laytonlib/\nuv run ruff format skills/layton/laytonlib/ --check\n\n# Run pre-commit\npre-commit run --all-files\n```\n\n## Exit Criteria\n\n```bash\n# All tests pass\nuv run pytest tests/layton/ -v\n\n# No lint errors\nuv run ruff check skills/layton/laytonlib/\n\n# CLI works end-to-end (manual test)\n./skills/layton/scripts/layton --version\n./skills/layton/scripts/layton doctor --fix\n./skills/layton/scripts/layton context\n\n# Beads integration works\nbd info --json\n```\n\n### Checklist\n- [ ] All unit tests pass (`uv run pytest tests/layton/unit/ -v`)\n- [ ] All e2e tests pass (`uv run pytest tests/layton/e2e/ -v`)\n- [ ] No ruff lint errors\n- [ ] CLI --version works\n- [ ] CLI doctor command works\n- [ ] CLI config init/show/get/set work\n- [ ] CLI context command works\n- [ ] Beads `bd info --json` succeeds\n- [ ] Beads integration tested (create/list with layton label)\n\n## Files to Modify\n\n(None - this is a verification task)\n\n## Notes\n\nThis task depends on all previous tasks being complete. It is a final verification step.","status":"closed","priority":1,"issue_type":"task","owner":"hild@b4mad.net","created_at":"2026-01-15T17:18:53.649351+01:00","created_by":"Marcel Hild","updated_at":"2026-01-15T18:01:28.702256+01:00","closed_at":"2026-01-15T18:01:28.702256+01:00","close_reason":"Done: All 76 tests pass, lint passes, CLI verified end-to-end, beads integration works","labels":["openspec:layton-stage0-foundation"],"dependencies":[{"issue_id":"durandom-42q.7","depends_on_id":"durandom-42q","type":"parent-child","created_at":"2026-01-15T17:18:53.65028+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.7","depends_on_id":"durandom-42q.3","type":"blocks","created_at":"2026-01-15T17:19:09.361882+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.7","depends_on_id":"durandom-42q.4","type":"blocks","created_at":"2026-01-15T17:19:10.303446+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.7","depends_on_id":"durandom-42q.5","type":"blocks","created_at":"2026-01-15T17:19:11.120377+01:00","created_by":"Marcel Hild"},{"issue_id":"durandom-42q.7","depends_on_id":"durandom-42q.6","type":"blocks","created_at":"2026-01-15T17:19:11.986206+01:00","created_by":"Marcel Hild"}]}
{"id":"durandom-ehr","title":"Extensible context: plugin architecture for layton context","description":"## Problem\n\nThe current `layton context` command returns only temporal data (time_of_day, work_hours, etc.). However, SKILL.md workflows often need richer situational awareness:\n\n- **Task pressure**: How many items are waiting? Is the inbox overflowing?\n- **Interrupt state**: Is there an active interrupt that should take priority?\n- **Energy/focus hints**: User-defined signals about current state\n- **Custom signals**: End-user extensible context providers\n\n## Proposed Solution\n\nMake context extensible via a plugin/provider architecture:\n\n```json\n{\n  \"temporal\": { ... },           // Built-in (current behavior)\n  \"tasks\": {                     // Provider: beads\n    \"waiting\": 12,\n    \"blocked\": 3,\n    \"inbox_count\": 5\n  },\n  \"interrupt\": {                 // Provider: user-defined\n    \"active\": true,\n    \"reason\": \"urgent-call\"\n  }\n}\n```\n\n## Design Considerations\n\n1. **Provider discovery**: How does Layton find context providers?\n2. **Schema flexibility**: Providers define their own output shape\n3. **Performance**: Context should remain fast (parallel provider calls?)\n4. **Graceful degradation**: Missing providers → omit section, don't fail\n\n## Tasks\n\n- [ ] Design provider interface (how providers register, what they return)\n- [ ] Implement provider discovery mechanism\n- [ ] Add built-in beads provider (task counts from `bd stats --json`)\n- [ ] Document how users can add custom providers\n\n## Blocked By\n\nThis is a **future improvement** (P4 backlog). Current Stage 0 scope is temporal-only context.","status":"tombstone","priority":4,"issue_type":"feature","owner":"hild@b4mad.net","created_at":"2026-01-15T16:49:05.832859+01:00","created_by":"Marcel Hild","updated_at":"2026-02-06T09:08:59.892027+01:00","deleted_at":"2026-02-06T09:08:59.892027+01:00","deleted_by":"daemon","delete_reason":"delete","original_type":"feature"}
