#!/usr/bin/env python3
"""GTD CLI - Getting Things Done task management."""

import sys
from pathlib import Path

# Ensure gtdlib is importable regardless of cwd (Pattern 1b)
_script_dir = Path(__file__).parent.resolve()
sys.path.insert(0, str(_script_dir))

import argparse  # noqa: E402
from datetime import date  # noqa: E402

from gtdlib.backends.github import GitHubStorage  # noqa: E402
from gtdlib.backends.taskwarrior import TaskwarriorStorage  # noqa: E402
from gtdlib.config import (  # noqa: E402
    AVAILABLE_BACKENDS,
    GTDConfig,
    detect_skill_directory,
    is_initialized,
    load_config,
    save_config,
)
from gtdlib.history import format_entry_human, log_action, read_history  # noqa: E402
from gtdlib.metadata import GTDMetadata  # noqa: E402
from gtdlib.reviews import (  # noqa: E402
    get_due_reviews,
    get_review_status,
    mark_review_complete,
    reset_review,
)
from gtdlib.storage import GTDItem, GTDStorage  # noqa: E402

# ANSI colors
BLUE = "\033[0;34m"
GREEN = "\033[0;32m"
YELLOW = "\033[0;33m"
RED = "\033[0;31m"
BOLD = "\033[1m"
NC = "\033[0m"  # No Color

# Derive valid labels from the storage layer (single source of truth)
CONTEXTS = list(GTDStorage.LABELS["context"].keys())
ENERGIES = list(GTDStorage.LABELS["energy"].keys())
STATUSES = list(GTDStorage.LABELS["status"].keys())
HORIZONS = list(GTDStorage.LABELS["horizon"].keys())

# Category metadata for label management
GTD_CATEGORIES = {
    "status": {"values": STATUSES, "prefix": "status/"},
    "context": {"values": CONTEXTS, "prefix": "context/"},
    "energy": {"values": ENERGIES, "prefix": "energy/"},
    "horizon": {"values": HORIZONS, "prefix": "horizon/"},
}


def print_next_steps(hints: list[tuple[str, str]]) -> None:
    """Print next-step hints at the end of output.

    Args:
        hints: List of (command, description) tuples.
    """
    print(f"\n{BOLD}Next steps:{NC}")
    for cmd, desc in hints:
        print(f"  {BOLD}{cmd:<24}{NC} {desc}")


def compute_label_changes(
    args, existing_labels: list[str] | None = None
) -> tuple[list[str], list[str]]:
    """Compute labels to add/remove based on args.

    Args:
        args: Parsed arguments with status, context, energy, horizon attrs.
        existing_labels: If provided, only remove labels that exist.
            If None, generate all possible labels to remove (bulk mode).

    Returns:
        Tuple of (labels_to_add, labels_to_remove).
    """
    labels_to_add = []
    labels_to_remove = []

    for category, meta in GTD_CATEGORIES.items():
        value = getattr(args, category, None)
        if value and value in meta["values"]:
            labels_to_add.append(f"{meta['prefix']}{value}")
            if existing_labels is not None:
                # Single-item mode: only remove existing labels with this prefix
                for label in existing_labels:
                    if label.startswith(meta["prefix"]):
                        labels_to_remove.append(label)
            else:
                # Bulk mode: list all possible labels to remove (filtered at execution)
                labels_to_remove.extend(
                    f"{meta['prefix']}{v}" for v in meta["values"] if v != value
                )

    return labels_to_add, labels_to_remove


class NotInitializedError(Exception):
    """Raised when GTD is not initialized."""

    pass


def get_storage(
    repo: str | None = None,
    backend: str | None = None,
    ensure_setup: bool = True,
    require_init: bool = True,
) -> GTDStorage:
    """Get the storage backend based on configuration.

    Args:
        repo: Optional repo in "owner/repo" format (for GitHub backend).
        backend: Override backend choice ('github' or 'taskwarrior').
            If None, uses the configuration from .gtd/config.json.
        ensure_setup: If True, automatically run setup if needed.
        require_init: If True, fail if not initialized (no .gtd/config.json).

    Raises:
        NotInitializedError: If require_init=True and no config exists.
    """
    # Check initialization (skip if backend override provided)
    if require_init and backend is None and not is_initialized():
        raise NotInitializedError(
            "GTD is not initialized. Run `gtd init` to configure."
        )

    config = load_config()
    backend_choice = backend or config.backend

    if backend_choice == "taskwarrior":
        storage: GTDStorage = TaskwarriorStorage(data_dir=config.taskwarrior.data_dir)
    elif backend_choice == "beads":
        from gtdlib.backends.beads import BeadsStorage

        storage = BeadsStorage(config=config.beads)
    else:
        storage = GitHubStorage(repo=repo or config.github.repo)

    if ensure_setup and not storage.is_setup():
        print(f"{YELLOW}GTD storage not set up. Running setup...{NC}\n")
        storage.setup(verbose=True)
        print()
    return storage


def format_item(item: GTDItem, show_labels: bool = False) -> str:
    """Format a single item for display."""
    line = f"  #{item.id} {item.title}"

    if show_labels:
        label_parts = []
        if item.context:
            label_parts.append(f"@{item.context}")
        if item.energy:
            label_parts.append(f"E:{item.energy}")
        if item.status:
            label_parts.append(f"S:{item.status}")
        if item.horizon:
            label_parts.append(f"H:{item.horizon}")
        if item.project:
            label_parts.append(f"P:{item.project}")
        if label_parts:
            line += f" {BLUE}[{' '.join(label_parts)}]{NC}"

    return line


def cmd_status(args) -> int:
    """Show GTD system status overview.

    Default command when gtd is run without arguments.
    Provides a quick snapshot and guides to next actions.
    """
    try:
        storage = get_storage(args.repo, args.backend)
    except NotInitializedError:
        # Not initialized - show init guidance
        print(f"{BLUE}GTD CLI{NC} - Getting Things Done task management")
        print(
            f"\n{YELLOW}!{NC} Not initialized. Run {BOLD}gtd init{NC} to get started."
        )
        return 0

    # Check for overdue reviews first (top priority)
    due_reviews = get_due_reviews()

    print(f"{BLUE}GTD Status{NC}")
    print("=" * 40)

    # Show prominent banner if any reviews are overdue
    if due_reviews:
        most_overdue = due_reviews[0]
        print(
            f"\n{RED}üö® REVIEW OVERDUE: {most_overdue.review_type.title()} review "
            f"({most_overdue.days_overdue} days){NC}"
        )
        print(f"   Run: {BOLD}gtd {most_overdue.review_type}{NC}")
        print(f"   üìñ Agent guide: {most_overdue.workflow_path}")

    # Gather counts
    inbox_items = storage.list_inbox()
    active_items = storage.list_items(
        labels=["status/active", "horizon/action"], limit=100
    )
    overdue_items = [i for i in active_items if i.is_overdue]

    # Inbox
    if inbox_items:
        print(f"\n{YELLOW}üì• Inbox:{NC} {len(inbox_items)} items need clarifying")
    else:
        print(f"\n{GREEN}üì• Inbox:{NC} Empty ‚úì")

    # Active actions with first action shown
    print(f"{BLUE}üìã Active:{NC} {len(active_items)} actions")
    if active_items:
        first_action = active_items[0]
        print(f"  ‚Üí #{first_action.id} {first_action.title}")

    # Overdue warning
    if overdue_items:
        print(f"{RED}‚ö† Overdue:{NC} {len(overdue_items)} items past due")

    # Review status section
    review_status = get_review_status()
    print(f"\n{BLUE}üîÑ Reviews:{NC}")
    for rtype in ["daily", "weekly", "quarterly", "yearly"]:
        status = review_status[rtype]
        if status["overdue"]:
            if status["days_ago"] is None:
                print(f"  {RED}‚ö†{NC} {rtype.title()}: never done")
            else:
                days = status["days_ago"]
                print(f"  {RED}‚ö†{NC} {rtype.title()}: {days} days ago (overdue)")
        else:
            if status["days_ago"] == 0:
                print(f"  {GREEN}‚úì{NC} {rtype.title()}: today")
            else:
                print(f"  {GREEN}‚úì{NC} {rtype.title()}: {status['days_ago']} days ago")

    # Build context-aware hints
    hints = []
    if due_reviews:
        # Overdue review is top priority
        most_overdue = due_reviews[0]
        hints.append(
            (
                f"gtd {most_overdue.review_type}",
                f"{most_overdue.review_type.title()} review (OVERDUE - top priority)",
            )
        )
    if inbox_items:
        first_id = inbox_items[0].id
        hints.append((f"gtd clarify {first_id}", "Process first inbox item"))
    hints.append(("gtd capture <text>", "Quick capture to inbox"))
    if active_items and not due_reviews:
        hints.append(("gtd next", "Get next action to work on"))
    hints.append(("gtd reviews", "View detailed review status"))

    print_next_steps(hints)
    return 0


def cmd_capture(args) -> int:
    """Quick capture to inbox."""
    storage = get_storage(args.repo, args.backend)
    text = " ".join(args.text)

    item = storage.capture(title=text, body=args.body)
    print(f"{GREEN}‚úì{NC} Captured to inbox: #{item.id}")
    print(f"  {item.title}")

    # Log to history
    log_action("capture", item_id=str(item.id), title=item.title)

    print_next_steps(
        [
            (f"gtd clarify {item.id}", "Process this item"),
            ("gtd inbox", "View all inbox items"),
        ]
    )
    return 0


def cmd_inbox(args) -> int:
    """List inbox items needing clarification."""
    storage = get_storage(args.repo, args.backend)
    items = storage.list_inbox()

    if not items:
        print(f"{GREEN}‚úì{NC} Inbox is empty! Nothing to clarify.")
        print_next_steps(
            [
                ("gtd capture <text>", "Capture a new thought"),
                ("gtd next", "Get next action to work on"),
            ]
        )
        return 0

    print(f"{BLUE}üì• Inbox ({len(items)} items){NC}")
    print("=" * 40)
    print()
    for item in items:
        print(f"  #{item.id} {item.title}")

    first_id = items[0].id
    print_next_steps(
        [
            (f"gtd clarify {first_id}", "Process first item"),
            ("gtd view <id>", "View item details"),
        ]
    )
    return 0


def cmd_clarify(args) -> int:
    """Clarify an inbox item (non-interactive, requires flags).

    Examples:
        gtd clarify 123 --status=active --context=focus
        gtd clarify 123 --not-actionable --delete
        gtd clarify 123 --not-actionable --someday
    """
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    # Check if any decision flags were provided
    has_actionable_flags = any(
        [
            getattr(args, "status", None),
            getattr(args, "context", None),
            getattr(args, "energy", None),
            getattr(args, "horizon", None),
            getattr(args, "project", None),
            getattr(args, "outcome", None),
            getattr(args, "next_action", None),
        ]
    )
    has_not_actionable = getattr(args, "not_actionable", False)

    # If no flags provided, show item and usage
    if not has_actionable_flags and not has_not_actionable:
        print(f"{BLUE}Item #{item.id}:{NC} {item.title}")
        if item.body:
            print(f"  {item.body[:100]}...")
        print()
        print(f"{YELLOW}Clarify requires flags to specify the decision:{NC}")
        print()
        print(f"{BOLD}If actionable:{NC}")
        print(f"  gtd clarify {args.id} --status=active --context=focus")
        print(f"  gtd clarify {args.id} --status=active --context=async --energy=low")
        print()
        print(f"{BOLD}If not actionable:{NC}")
        print(f"  gtd clarify {args.id} --not-actionable --delete")
        print(f"  gtd clarify {args.id} --not-actionable --someday")
        print(f"  gtd clarify {args.id} --not-actionable --reference")
        print()
        print(f"Options: --status ({', '.join(STATUSES)})")
        print(f"         --context ({', '.join(CONTEXTS)})")
        print(f"         --energy ({', '.join(ENERGIES)})")
        print(f"         --horizon ({', '.join(HORIZONS)})")
        print("         --project <name>")
        print("         --outcome <text>")
        print("         --next-action <text>")
        return 1

    print(f"{BLUE}Clarifying:{NC} #{item.id} {item.title}")

    # Handle non-actionable items
    if has_not_actionable:
        if getattr(args, "delete", False):
            storage.close_item(args.id)
            print(f"{GREEN}‚úì{NC} Deleted (closed).")
        elif getattr(args, "someday", False):
            print(f"{GREEN}‚úì{NC} Staying in someday/maybe.")
        elif getattr(args, "reference", False):
            print(
                f"{YELLOW}!{NC} Reference items should be moved to your notes system."
            )
        else:
            print(
                f"{YELLOW}‚ö†{NC} --not-actionable requires "
                "--delete, --someday, or --reference"
            )
            return 1
        print_next_steps(
            [
                ("gtd inbox", "Process next inbox item"),
                ("gtd list", "List all tasks"),
            ]
        )
        return 0

    # Actionable item processing
    labels_to_add = []
    labels_to_remove = ["status/someday"]  # Remove inbox status

    # Update next action (title)
    next_action = getattr(args, "next_action", None)
    if next_action and next_action != item.title:
        try:
            storage.update_item(args.id, title=next_action)
        except (ValueError, RuntimeError) as e:
            print(f"{RED}‚úó{NC} Failed to update title for #{args.id}: {e}")
            return 1

    # Horizon (default to action)
    horizon = getattr(args, "horizon", None) or "action"
    if horizon in HORIZONS:
        labels_to_add.append(f"horizon/{horizon}")

    # Context
    context = getattr(args, "context", None)
    if context and context in CONTEXTS:
        labels_to_add.append(f"context/{context}")

    # Energy
    energy = getattr(args, "energy", None)
    if energy and energy in ENERGIES:
        labels_to_add.append(f"energy/{energy}")

    # Status (default to active)
    status = getattr(args, "status", None) or "active"
    if status in STATUSES:
        labels_to_add.append(f"status/{status}")

    # Project
    project = getattr(args, "project", None)
    if project:
        storage.ensure_project(project)
        storage.update_item(args.id, project=project)

    # Apply label changes
    storage.remove_labels(args.id, labels_to_remove)
    if labels_to_add:
        storage.add_labels(args.id, labels_to_add)

    # Update body with outcome if provided
    outcome = getattr(args, "outcome", None)
    if outcome:
        new_body = f"**Outcome:** {outcome}\n\n{item.body or ''}"
        storage.update_item(args.id, body=new_body)

    updated = storage.get_item(args.id)
    print(f"{GREEN}‚úì{NC} Item clarified and organized!")
    print(format_item(updated, show_labels=True))

    # Log to history
    log_action("clarify", item_id=args.id, title=updated.title, labels=labels_to_add)

    print_next_steps(
        [
            ("gtd inbox", "Process next inbox item"),
            (f"gtd done {args.id}", "Mark complete when done"),
        ]
    )
    return 0


def cmd_add(args) -> int:
    """Add a new clarified task."""
    storage = get_storage(args.repo, args.backend)
    title = " ".join(args.title)
    labels = []

    # Context
    if args.context and args.context in CONTEXTS:
        labels.append(f"context/{args.context}")

    # Energy
    if args.energy and args.energy in ENERGIES:
        labels.append(f"energy/{args.energy}")

    # Status (timing) - default to active
    if args.status and args.status in STATUSES:
        labels.append(f"status/{args.status}")
    else:
        labels.append("status/active")

    # Horizon (altitude) - default to action
    if args.horizon and args.horizon in HORIZONS:
        labels.append(f"horizon/{args.horizon}")
    else:
        labels.append("horizon/action")

    # Handle project
    project = args.project
    if args.horizon == "project" and not project:
        # Auto-create project for horizon/project items
        project = title
        storage.ensure_project(title)

    item = storage.create_item(
        title=title, labels=labels, body=args.body, project=project
    )
    log_action("add", item_id=str(item.id), title=item.title, labels=labels)
    print(f"{GREEN}‚úì{NC} Created: #{item.id} {item.title}")
    if args.horizon == "project":
        print(f"  Project '{title}' created.")

    print_next_steps(
        [
            (f"gtd done {item.id}", "Mark complete when done"),
            (f"gtd view {item.id}", "View item details"),
            ("gtd list", "List all tasks"),
        ]
    )
    return 0


def cmd_list(args) -> int:
    """List tasks with filters."""
    storage = get_storage(args.repo, args.backend)
    labels = []

    if args.context and args.context in CONTEXTS:
        labels.append(f"context/{args.context}")
    if args.energy and args.energy in ENERGIES:
        labels.append(f"energy/{args.energy}")
    if args.status and args.status in STATUSES:
        labels.append(f"status/{args.status}")
    if args.horizon and args.horizon in HORIZONS:
        labels.append(f"horizon/{args.horizon}")

    verbose = getattr(args, "verbose", False)

    if verbose:
        print(f"{BLUE}[DEBUG] Filters:{NC}")
        print(f"  labels: {labels if labels else '(none)'}")
        print(f"  state: {args.state}")
        print(f"  limit: {args.limit}")
        print()

    items = storage.list_items(
        labels=labels if labels else None,
        state=args.state,
        project=args.project,
        limit=args.limit,
        verbose=verbose,
    )

    # Apply date-based filters (post-fetch filtering)
    due_before = getattr(args, "due_before", None)
    if due_before:
        try:
            target = date.fromisoformat(due_before)
            items = [i for i in items if i.due and i.due <= target]
        except ValueError:
            print(f"{RED}Error:{NC} Invalid date format for --due-before.")
            print("  Use YYYY-MM-DD.")
            return 1

    if getattr(args, "overdue", False):
        items = [i for i in items if i.is_overdue]

    if getattr(args, "deferred", False):
        items = [i for i in items if i.is_deferred]

    if getattr(args, "not_deferred", False):
        items = [i for i in items if not i.is_deferred]

    if getattr(args, "blocked", False):
        items = [i for i in items if i.blocked_by]

    waiting_on = getattr(args, "waiting_on", None)
    if waiting_on:
        items = [
            i
            for i in items
            if i.waiting_for
            and waiting_on.lower() in i.waiting_for.get("person", "").lower()
        ]

    if not items:
        print("No items found matching criteria.")
        print_next_steps(
            [
                ("gtd capture <text>", "Capture a new thought"),
                ("gtd inbox", "Process inbox items"),
            ]
        )
        return 0

    # Group by context if no specific context filter
    if not args.context and not args.raw:
        by_context: dict[str, list[GTDItem]] = {}
        for item in items:
            ctx = item.context or "none"
            if ctx not in by_context:
                by_context[ctx] = []
            by_context[ctx].append(item)

        for ctx, ctx_items in by_context.items():
            print(f"\n{BLUE}@{ctx}{NC} ({len(ctx_items)} items)")
            for item in ctx_items:
                print(format_item(item, show_labels=True))
    else:
        for item in items:
            print(format_item(item, show_labels=True))

    print_next_steps(
        [
            ("gtd done <id>", "Mark task complete"),
            ("gtd view <id>", "View task details"),
            ("gtd next", "Get next action"),
        ]
    )
    return 0


def cmd_done(args) -> int:
    """Mark task as complete."""
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    # Close item first (primary operation)
    try:
        storage.close_item(args.id)
    except Exception as exc:
        print(f"{RED}Error:{NC} Failed to close item #{args.id}: {exc}")
        return 1

    # Add comment if provided (secondary operation, after successful close)
    if args.comment:
        try:
            storage.add_comment(args.id, args.comment)
        except Exception as exc:
            print(f"{YELLOW}Warning:{NC} Failed to add comment: {exc}")
        else:
            suffix = "..." if len(args.comment) > 50 else ""
            print(f"  Added comment: {args.comment[:50]}{suffix}")

    print(f"{GREEN}‚úì{NC} Completed: #{item.id} {item.title}")

    # Log to history
    log_action("done", item_id=str(item.id), title=item.title)

    print_next_steps(
        [
            ("gtd next", "Get next action to work on"),
            ("gtd list", "List remaining tasks"),
            ("gtd inbox", "Process inbox items"),
        ]
    )
    return 0


def cmd_update(args) -> int:
    """Update an existing task's GTD labels."""
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    # Compute label changes (pass existing labels for precise removal)
    labels_to_add, labels_to_remove = compute_label_changes(args, item.labels)

    # Check that at least one update was requested
    if not any([labels_to_add, labels_to_remove, args.project]):
        print(f"{YELLOW}‚ö†{NC} No updates specified.")
        print("  Use --status, --context, --energy, --horizon, or --project")
        return 1

    # Handle project change
    if args.project:
        storage.ensure_project(args.project)
        storage.update_item(args.id, project=args.project)

    # Apply label changes
    if labels_to_remove:
        storage.remove_labels(args.id, labels_to_remove)
    if labels_to_add:
        storage.add_labels(args.id, labels_to_add)

    # Show result
    updated = storage.get_item(args.id)
    log_action(
        "update",
        item_id=args.id,
        title=updated.title,
        labels_added=labels_to_add or None,
        labels_removed=labels_to_remove or None,
        project=args.project,
    )
    print(f"{GREEN}‚úì{NC} Updated: #{updated.id} {updated.title}")
    print(format_item(updated, show_labels=True))

    print_next_steps(
        [
            (f"gtd done {args.id}", "Mark complete when done"),
            (f"gtd view {args.id}", "View full details"),
            ("gtd list", "List all tasks"),
        ]
    )
    return 0


def cmd_comment(args) -> int:
    """Add a comment to a task."""
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    message = " ".join(args.message)
    try:
        storage.add_comment(args.id, message)
    except Exception as e:
        print(f"{RED}Error:{NC} Failed to add comment to #{item.id}: {e}")
        return 1
    log_action("comment", item_id=args.id, title=item.title)
    print(f"{GREEN}‚úì{NC} Comment added to #{item.id}")
    print(f"  {message[:80]}{'...' if len(message) > 80 else ''}")

    print_next_steps(
        [
            (f"gtd view {args.id}", "View full task"),
            (f"gtd done {args.id}", "Mark complete"),
        ]
    )
    return 0


def cmd_view(args) -> int:
    """View a task with GTD-relevant info highlighted."""
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    # Header
    state_color = GREEN if item.state == "open" else RED
    print(f"\n{BLUE}#{item.id}{NC} {BOLD}{item.title}{NC}")
    print(f"State: {state_color}{item.state}{NC}")
    print("=" * 50)

    # GTD Properties
    print(f"\n{BOLD}GTD Properties:{NC}")
    print(f"  Context:  {item.context or '(none)'}")
    print(f"  Energy:   {item.energy or '(none)'}")
    print(f"  Status:   {item.status or '(none)'}")
    print(f"  Horizon:  {item.horizon or '(none)'}")
    if item.project:
        print(f"  Project:  {item.project}")

    # All labels
    non_gtd_labels = [
        label
        for label in item.labels
        if not any(label.startswith(p) for p in GTDStorage.get_label_prefixes())
    ]
    if non_gtd_labels:
        print(f"\n{BOLD}Other Labels:{NC} {', '.join(non_gtd_labels)}")

    # Body
    if item.body:
        print(f"\n{BOLD}Description:{NC}")
        # Truncate long bodies
        body_lines = item.body.split("\n")[:15]
        for line in body_lines:
            print(f"  {line}")
        if len(item.body.split("\n")) > 15:
            print(f"  {YELLOW}... (truncated){NC}")

    # Metadata
    print(f"\n{BOLD}Metadata:{NC}")
    if item.created_at:
        print(f"  Created:  {item.created_at[:10]}")
    if item.closed_at:
        print(f"  Closed:   {item.closed_at[:10]}")
    if item.url:
        print(f"  URL:      {item.url}")

    # Context-aware hints based on item state
    hints = []
    if item.state == "open":
        hints.append((f"gtd done {args.id}", "Mark complete"))
        hints.append((f"gtd update {args.id} --status=...", "Update GTD labels"))
    hints.append(("gtd list", "List all tasks"))

    print_next_steps(hints)
    return 0


def cmd_bulk(args) -> int:
    """Perform bulk operations on multiple tasks."""
    storage = get_storage(args.repo, args.backend)

    # Parse issue numbers
    ids = []
    for part in args.ids.split(","):
        part = part.strip()
        if "-" in part:
            # Range like 36-38
            start, end = (s.strip() for s in part.split("-", 1))
            # Validate that both bounds are non-empty and numeric
            if not start.isdigit() or not end.isdigit():
                print(f"{RED}Error:{NC} Invalid range '{part}'.")
                print("  Use START-END with positive integers.")
                return 1
            start_int = int(start)
            end_int = int(end)
            if start_int > end_int:
                print(f"{RED}Error:{NC} Invalid range '{part}'.")
                print("  Start cannot be greater than end.")
                return 1
            ids.extend(str(i) for i in range(start_int, end_int + 1))
        else:
            if not part.isdigit():
                print(f"{RED}Error:{NC} Invalid item ID '{part}'.")
                print("  Must be a positive integer.")
                return 1
            ids.append(part)

    if not ids:
        print(f"{RED}Error:{NC} No item IDs provided.")
        return 1

    # Determine operation (no existing_labels = bulk mode, filtered at execution)
    labels_to_add, labels_to_remove = compute_label_changes(args)

    # Handle custom label add/remove (bulk-specific)
    if args.add_label:
        labels_to_add.append(args.add_label)
    if args.remove_label:
        labels_to_remove.append(args.remove_label)

    # Check if closing
    close_items = args.close

    if not any([labels_to_add, labels_to_remove, close_items, args.project]):
        print(f"{YELLOW}‚ö†{NC} No operation specified.")
        print("  Use --status, --context, --energy, --horizon, --add-label,")
        print("  --remove-label, --project, or --close")
        return 1

    # Preview mode
    if not args.force:
        print(f"\n{BLUE}[PREVIEW] Bulk operation on {len(ids)} items:{NC}")
        if labels_to_add:
            print(f"  Add labels: {', '.join(labels_to_add)}")
        if labels_to_remove:
            print(f"  Remove labels: {', '.join(labels_to_remove)}")
        if args.project:
            print(f"  Set project: {args.project}")
        if close_items:
            print("  Close items: yes")
        print(f"\n  Items: {', '.join(ids[:10])}{'...' if len(ids) > 10 else ''}")
        print(f"\n{YELLOW}Run with --force to execute.{NC}")
        return 0

    # Execute
    success = 0
    failed = 0

    for item_id in ids:
        try:
            item = storage.get_item(item_id)
            if not item:
                print(f"  {RED}‚úó{NC} #{item_id} not found")
                failed += 1
                continue

            if labels_to_remove:
                # Only remove labels that actually exist on this item
                existing_labels = set(getattr(item, "labels", []) or [])
                labels_to_remove_for_item = [
                    label for label in labels_to_remove if label in existing_labels
                ]
                if labels_to_remove_for_item:
                    storage.remove_labels(item_id, labels_to_remove_for_item)
            if labels_to_add:
                storage.add_labels(item_id, labels_to_add)
            if args.project:
                storage.ensure_project(args.project)
                storage.update_item(item_id, project=args.project)
            if close_items:
                storage.close_item(item_id)

            # Log each successful bulk operation
            log_action(
                "bulk",
                item_id=item_id,
                title=item.title,
                labels_added=labels_to_add or None,
                labels_removed=labels_to_remove_for_item if labels_to_remove else None,
                project=args.project,
                closed=close_items,
            )
            print(f"  {GREEN}‚úì{NC} #{item_id} {(item.title or '')[:40]}...")
            success += 1
        except Exception as e:
            print(f"  {RED}‚úó{NC} #{item_id}: {e}")
            failed += 1

    print(f"\n{GREEN}‚úì{NC} Completed: {success} succeeded, {failed} failed")

    print_next_steps(
        [
            ("gtd list", "View all tasks"),
            ("gtd next", "Get next action"),
        ]
    )
    return 0 if failed == 0 else 1


def cmd_next(args) -> int:
    """Show the next action to work on.

    Returns a single prioritized task based on context and energy filters.
    Priority: high energy focus work > low energy focus > async > other contexts.
    """
    storage = get_storage(args.repo, args.backend)

    # Build filter labels
    labels = ["status/active", "horizon/action"]
    if args.context and args.context in CONTEXTS:
        labels.append(f"context/{args.context}")
    if args.energy and args.energy in ENERGIES:
        labels.append(f"energy/{args.energy}")

    # If no filters provided, try to find the best next action
    if not args.context and not args.energy:
        # Priority order for finding next action
        priority_filters = [
            (["context/focus", "energy/high", "status/active"], "üß† High-energy focus"),
            (["context/focus", "energy/low", "status/active"], "üìù Low-energy focus"),
            (["context/focus", "status/active"], "üíª Focus work"),
            (["context/async", "status/active"], "üì± Async work"),
            (["status/active", "horizon/action"], "üìã Active action"),
        ]

        for filter_labels, label_desc in priority_filters:
            items = storage.list_items(labels=filter_labels, limit=1)
            if items:
                item = items[0]
                print(f"\n{BLUE}Next action ({label_desc}):{NC}")
                print(f"  #{item.id} {item.title}")
                if item.project:
                    print(f"  {YELLOW}Project:{NC} {item.project}")
                print_next_steps(
                    [
                        (f"gtd done {item.id}", "Mark complete when done"),
                        (f"gtd view {item.id}", "View details"),
                    ]
                )
                return 0

        print(f"{GREEN}‚úì{NC} No active actions found. Time to clarify inbox or relax!")
        print_next_steps(
            [
                ("gtd inbox", "Process inbox items"),
                ("gtd capture <text>", "Capture a new thought"),
            ]
        )
        return 0

    # With filters, just get the first matching item
    items = storage.list_items(labels=labels, limit=1)
    if items:
        item = items[0]
        print(f"\n{BLUE}Next action:{NC}")
        print(format_item(item, show_labels=True))
        if item.project:
            print(f"  {YELLOW}Project:{NC} {item.project}")
        print_next_steps(
            [
                (f"gtd done {item.id}", "Mark complete when done"),
                (f"gtd view {item.id}", "View details"),
            ]
        )
    else:
        print("No matching actions found.")
        print_next_steps(
            [
                ("gtd inbox", "Process inbox items"),
                ("gtd list", "List all tasks"),
            ]
        )

    return 0


def cmd_daily(args) -> int:
    """Daily review workflow."""
    storage = get_storage(args.repo, args.backend)

    print(f"\n{BLUE}üåÖ Daily Review{NC}")
    print("=" * 40)

    # 1. High energy focus work
    print(f"\n{BOLD}üß† High Energy Focus Work (morning){NC}")
    items = storage.list_items(
        labels=["context/focus", "energy/high", "status/active"], limit=10
    )
    if items:
        for item in items:
            print(format_item(item))
    else:
        print("  (none)")

    # 2. Light focus work
    print(f"\n{BOLD}üìù Light Focus Work{NC}")
    items = storage.list_items(
        labels=["context/focus", "energy/low", "status/active"], limit=10
    )
    if items:
        for item in items:
            print(format_item(item))
    else:
        print("  (none)")

    # 3. Async work
    print(f"\n{BOLD}üì± Async Work (anytime){NC}")
    items = storage.list_items(labels=["context/async", "status/active"], limit=10)
    if items:
        for item in items:
            print(format_item(item))
    else:
        print("  (none)")

    # 4. Waiting
    print(f"\n{BOLD}‚è≥ Waiting on Others{NC}")
    items = storage.list_items(labels=["status/waiting"], limit=10)
    if items:
        for item in items:
            print(format_item(item))
            # Show who we're waiting on if available
            if item.waiting_for:
                person = item.waiting_for.get("person", "")
                reason = item.waiting_for.get("reason", "")
                if person:
                    wait_info = f"Waiting on: {person}"
                    if reason:
                        wait_info += f" ({reason})"
                    print(f"    {YELLOW}{wait_info}{NC}")
    else:
        print("  (none)")

    # 5. Deferred items now active
    print(f"\n{BOLD}üîî Deferred Items Now Active{NC}")
    all_someday = storage.list_items(labels=["status/someday"], limit=50)
    now_active = [
        i for i in all_someday if i.defer_until and i.defer_until <= date.today()
    ]
    if now_active:
        for item in now_active:
            print(f"  #{item.id} {item.title}")
            print(f"    {YELLOW}Was deferred until: {item.defer_until}{NC}")
        print(f"\n  Consider: {BOLD}gtd update <id> --status active{NC}")
    else:
        print("  (none)")

    # 6. Overdue items
    print(f"\n{BOLD}üö® Overdue Items{NC}")
    active_items = storage.list_items(labels=["status/active"], limit=100)
    overdue = [i for i in active_items if i.is_overdue]
    if overdue:
        for item in overdue:
            days = (date.today() - item.due).days
            print(f"  {RED}#{item.id}{NC} {item.title}")
            print(f"    Due: {item.due} ({days} days ago)")
    else:
        print(f"  {GREEN}‚úì{NC} No overdue items")

    # 7. Blocked items - check if blockers resolved
    print(f"\n{BOLD}üîì Blocked Items (Check Blockers){NC}")
    waiting_items = storage.list_items(labels=["status/waiting"], limit=50)
    blocked_items = [i for i in waiting_items if i.blocked_by]
    if blocked_items:
        for item in blocked_items:
            print(f"  #{item.id} {item.title}")
            all_resolved = True
            for bid in item.blocked_by:
                blocker = storage.get_item(str(bid))
                if not blocker:
                    # Blocker not found - treat as unresolved (might be deleted)
                    all_resolved = False
                    print(f"    ‚õî Blocked by #{bid}: (not found)")
                elif blocker.state == "open":
                    all_resolved = False
                    print(f"    ‚õî Blocked by #{bid}: {(blocker.title or '')[:40]}...")
            if all_resolved:
                print(f"    {GREEN}All blockers resolved!{NC}")
                print(f"    Consider: {BOLD}gtd blocked {item.id} --clear{NC}")
    else:
        print("  (none)")

    # 8. Inbox check
    inbox = storage.list_inbox()
    if inbox:
        print(f"\n{YELLOW}üì• Inbox has {len(inbox)} items to clarify{NC}")

    # Mark daily review as complete and log to history
    mark_review_complete("daily")
    log_action("review", review_type="daily")
    print(f"\n{GREEN}‚úì Daily review marked complete{NC}")

    # Build context-aware hints
    hints = []
    if inbox:
        hints.append((f"gtd clarify {inbox[0].id}", "Process first inbox item"))
    hints.append(("gtd next", "Get next action"))
    hints.append(("gtd weekly", "Run weekly review"))

    print_next_steps(hints)
    return 0


def cmd_weekly(args) -> int:
    """Weekly review workflow."""
    storage = get_storage(args.repo, args.backend)

    print(f"\n{BLUE}üìÖ Weekly Review{NC}")
    print("=" * 40)

    # 1. Process inbox
    inbox = storage.list_inbox()
    print(f"\n{BOLD}1. Process Inbox ({len(inbox)} items){NC}")
    if inbox:
        for item in inbox:
            print(f"  #{item.id} {item.title}")
        print(f"\n  Run {BOLD}gtd clarify <id>{NC} for each item.")
    else:
        print(f"  {GREEN}‚úì{NC} Inbox is empty!")

    # 2. Review active items
    print(f"\n{BOLD}2. Active Items (status/active){NC}")
    items = storage.list_items(labels=["status/active"], limit=20)
    if items:
        for item in items:
            print(format_item(item, show_labels=True))
    else:
        print("  (none)")

    # 3. Review waiting items
    print(f"\n{BOLD}3. Waiting For (status/waiting){NC}")
    items = storage.list_items(labels=["status/waiting"], limit=10)
    if items:
        for item in items:
            print(format_item(item))
    else:
        print("  (none)")

    # 4. Review projects
    print(f"\n{BOLD}4. Projects (horizon/project){NC}")
    items = storage.list_items(labels=["horizon/project"], limit=10)
    if items:
        for item in items:
            print(format_item(item))
        print("\n  Ensure each project has at least one active action!")
    else:
        print("  (none)")

    # 5. Review someday/maybe
    print(f"\n{BOLD}5. Someday/Maybe (status/someday){NC}")
    items = storage.list_items(labels=["status/someday"], limit=5)
    # Exclude inbox items
    items = [item for item in items if not item.is_inbox]
    if items:
        for item in items:
            print(format_item(item))
        print(f"  ... run {BOLD}gtd list --status someday{NC} for full list")
    else:
        print("  (none)")

    # Mark weekly review as complete and log to history
    mark_review_complete("weekly")
    log_action("review", review_type="weekly")
    print(f"\n{GREEN}‚úì Weekly review marked complete{NC}")

    # Build context-aware hints
    hints = []
    if inbox:
        hints.append((f"gtd clarify {inbox[0].id}", "Process first inbox item"))
    hints.append(("gtd next", "Get next action"))
    hints.append(("gtd projects", "Review project progress"))

    print_next_steps(hints)
    return 0


def cmd_init(args) -> int:
    """Initialize GTD with a storage backend.

    Safe-by-default: without backend argument, shows available options.
    """
    gh_ok = _check_tool("gh")
    task_ok = _check_tool("task")

    # If no backend specified, show available options (discovery mode)
    if not args.backend_choice:
        print(f"{BLUE}GTD Initialization{NC}")
        print("=" * 40)
        print()

        if is_initialized():
            config = load_config()
            print(f"{GREEN}‚úì{NC} Already initialized: {BOLD}{config.backend}{NC}")
            print()
            print(f"  To switch backends, run: {BOLD}gtd init <backend>{NC}")
        else:
            print("Choose a storage backend:")
            print()

            # GitHub option
            gh_status = f"{GREEN}‚úì ready{NC}" if gh_ok else f"{RED}‚úó not found{NC}"
            print(f"  {BOLD}github{NC}      - Store tasks as GitHub Issues")
            print(f"              gh CLI: {gh_status}")
            if not gh_ok:
                print(f"              Install: {BOLD}brew install gh{NC}")
            print()

            # Taskwarrior option
            task_status = f"{GREEN}‚úì ready{NC}" if task_ok else f"{RED}‚úó not found{NC}"
            print(f"  {BOLD}taskwarrior{NC} - Store tasks locally")
            print(f"              task CLI: {task_status}")
            if not task_ok:
                print(f"              Install: {BOLD}brew install task{NC}")
            print()

            print(f"Run: {BOLD}gtd init <backend>{NC}")

        return 0

    backend = args.backend_choice

    # Validate backend
    if backend not in AVAILABLE_BACKENDS:
        print(f"{RED}‚úó{NC} Unknown backend: {backend}")
        print(f"  Available: {', '.join(AVAILABLE_BACKENDS)}")
        return 1

    # Check if required tool is installed
    if backend == "github" and not gh_ok:
        print(f"{RED}‚úó{NC} Cannot use github backend: gh CLI not found")
        print()
        print(f"  Install: {BOLD}brew install gh{NC}")
        print(f"  Then:    {BOLD}gh auth login{NC}")
        return 1
    if backend == "taskwarrior" and not task_ok:
        print(f"{RED}‚úó{NC} Cannot use taskwarrior backend: task CLI not found")
        print()
        print(f"  Install: {BOLD}brew install task{NC}")
        return 1
    if backend == "beads" and not _check_tool("bd"):
        print(f"{RED}‚úó{NC} Cannot use beads backend: bd CLI not found")
        print()
        print(f"  Install: {BOLD}https://github.com/kortina/beads{NC}")
        print(f"  Then:    {BOLD}bd init{NC}")
        return 1

    # Check if already initialized
    if is_initialized():
        config = load_config()
        if config.backend == backend and not args.force:
            print(f"{GREEN}‚úì{NC} Already initialized with {BOLD}{backend}{NC}")
            return 0
        if not args.force:
            print(f"{YELLOW}!{NC} Already initialized: {BOLD}{config.backend}{NC}")
            print(f"  To switch to {backend}: {BOLD}gtd init {backend} --force{NC}")
            return 1

    # Create config
    config = GTDConfig(backend=backend)
    path = save_config(config)

    print(f"{GREEN}‚úì{NC} Initialized GTD with {BOLD}{backend}{NC} backend")
    print(f"  Config saved to: {path}")

    # Run setup for the chosen backend
    print()
    storage = get_storage(args.repo, backend, ensure_setup=False, require_init=False)
    if not storage.is_setup():
        print(f"{BLUE}Setting up {backend} storage...{NC}\n")
        storage.setup(verbose=True)

    return 0


def cmd_setup(args) -> int:
    """Run setup for the storage backend."""
    storage = get_storage(
        args.repo, args.backend, ensure_setup=False, require_init=False
    )

    # Cleanup mode - preview by default, --force to execute
    if args.cleanup:
        return _do_cleanup(storage, execute=args.force)

    # Check mode - detailed status report
    if args.check:
        return _do_check(storage)

    # Run setup
    if storage.is_setup() and not args.force:
        print(f"{GREEN}‚úì{NC} GTD storage is already set up.")
        print(f"  Use {BOLD}--check{NC} for detailed status.")
        print(f"  Use {BOLD}--force{NC} to recreate labels.")
        return 0

    print(f"{BLUE}Setting up GTD storage...{NC}\n")
    storage.setup(verbose=True, fix_drift=args.force)
    return 0


def _do_check(storage) -> int:
    """Detailed setup status check."""
    print(f"\n{BLUE}GTD Setup Status{NC}")
    print("=" * 40)

    # 1. Check required labels
    existing = storage.get_existing_labels()
    required = storage.get_required_labels()
    missing = required - existing
    present = required & existing

    print(f"\n{BOLD}Required Labels ({len(required)}):{NC}")
    if len(present) == len(required):
        print(f"  {GREEN}‚úì{NC} {len(present)}/{len(required)} present")
    else:
        print(f"  {YELLOW}‚ö†{NC} {len(present)}/{len(required)} present")
        for label in sorted(missing):
            print(f"    {RED}‚úó{NC} {label}")

    # 2. Check for drift (wrong color/description)
    drift = storage.get_label_drift()
    if drift:
        print(f"\n{BOLD}Label Drift ({len(drift)}):{NC}")
        for d in drift:
            print(f"  {YELLOW}‚ö†{NC} {d['name']}: {d['field']}")
            print(f"      expected: {d['expected']}")
            print(f"      actual:   {d['actual']}")
        print(f"\n  Run {BOLD}gtd setup --force{NC} to fix drift.")
    else:
        print(f"\n{BOLD}Label Drift:{NC}")
        print(f"  {GREEN}‚úì{NC} All labels have correct colors/descriptions")

    # 3. Check for stale labels
    stale = storage.get_stale_labels()
    if stale:
        print(f"\n{BOLD}Stale Labels ({len(stale)}):{NC}")
        print(
            f"  {YELLOW}‚ö†{NC} Found labels with GTD prefixes not in current taxonomy:"
        )
        for label in stale:
            print(f"    - {label}")
        print(f"\n  Run {BOLD}gtd setup --cleanup{NC} to preview removal.")
        print(f"  Run {BOLD}gtd setup --cleanup --force{NC} to remove them.")
    else:
        print(f"\n{BOLD}Stale Labels:{NC}")
        print(f"  {GREEN}‚úì{NC} No stale GTD labels found")

    # Summary
    print()
    if missing or drift or stale:
        return 1
    return 0


def _do_cleanup(storage, execute: bool = False) -> int:
    """Clean up stale GTD labels.

    Args:
        execute: If True, actually delete labels. If False (default), preview only.

    Returns:
        0 on success, 1 if any deletions failed.
    """
    stale = storage.get_stale_labels()

    if not stale:
        print(f"{GREEN}‚úì{NC} No stale labels to clean up.")
        return 0

    if execute:
        print(f"\n{BLUE}Cleaning up stale labels{NC}")
    else:
        print(f"\n{BLUE}[PREVIEW] Stale labels to clean up{NC}")
    print("=" * 40)

    failed = 0
    for label in stale:
        if execute:
            if storage.delete_label(label):
                print(f"  {GREEN}‚úì{NC} deleted: {label}")
            else:
                print(f"  {RED}‚úó{NC} failed to delete: {label}")
                failed += 1
        else:
            print(f"  {YELLOW}would delete:{NC} {label}")

    if not execute:
        print(f"\n{YELLOW}This was a preview.{NC} Run with --force to delete.")

    return 1 if failed else 0


def cmd_projects(args) -> int:
    """List all projects with progress."""
    storage = get_storage(args.repo, args.backend)

    # Get milestones (projects)
    milestones = storage.list_milestones(state=args.state)

    # Plain format: just titles, one per line (for machine parsing)
    output_format = getattr(args, "format", "pretty")
    if output_format == "plain":
        for m in milestones:
            print(m.get("title", "Untitled"))
        return 0

    # Pretty format: decorated output with progress bars
    print(f"\n{BLUE}üìä Projects{NC}")
    print("=" * 40)

    if not milestones:
        print("\nNo projects found.")
        print(f"\nCreate one with: {BOLD}gtd add 'Project Name' --horizon project{NC}")
        return 0

    for m in milestones:
        title = m.get("title", "Untitled")
        open_issues = m.get("open_issues", 0)
        closed_issues = m.get("closed_issues", 0)
        total = open_issues + closed_issues

        if total > 0:
            pct = int((closed_issues / total) * 100)
            bar_len = 20
            filled = int(bar_len * closed_issues / total)
            bar = "‚ñà" * filled + "‚ñë" * (bar_len - filled)
            print(f"\n  {BOLD}{title}{NC}")
            print(f"    [{bar}] {pct}% ({closed_issues}/{total})")
        else:
            print(f"\n  {BOLD}{title}{NC}")
            print("    No actions yet")

        if m.get("due_on"):
            due = m["due_on"][:10]  # Just the date part
            print(f"    Due: {due}")

    print()
    return 0


def cmd_quarterly(args) -> int:
    """Quarterly review workflow."""
    storage = get_storage(args.repo, args.backend)

    print(f"\n{BLUE}üóìÔ∏è  Quarterly Review{NC}")
    print("=" * 40)

    # 1. Review goals
    print(f"\n{BOLD}1. Goals (horizon/goal){NC}")
    goals = storage.list_items(labels=["horizon/goal"], limit=20)
    if goals:
        for item in goals:
            print(format_item(item, show_labels=True))
        print("\n  Are these still relevant? Any progress?")
    else:
        print("  No goals defined.")
        print(f"  Create goals with: {BOLD}gtd add 'Goal' --horizon goal{NC}")

    # 2. Review projects
    print(f"\n{BOLD}2. Projects (horizon/project){NC}")
    projects = storage.list_items(labels=["horizon/project"], limit=20)
    if projects:
        for item in projects:
            print(format_item(item, show_labels=True))
        print("\n  Which projects should continue? Close completed ones.")
    else:
        print("  No active projects.")

    # 3. Project progress
    print(f"\n{BOLD}3. Project Progress{NC}")
    milestones = storage.list_milestones()
    if milestones:
        for m in milestones:
            title = m.get("title", "Untitled")
            open_issues = m.get("open_issues", 0)
            closed_issues = m.get("closed_issues", 0)
            total = open_issues + closed_issues
            if total > 0:
                pct = int((closed_issues / total) * 100)
                print(f"  {title}: {pct}% ({closed_issues}/{total})")
            else:
                print(f"  {title}: No actions")
    else:
        print("  No projects to review.")

    # 4. Someday/Maybe items
    print(f"\n{BOLD}4. Someday/Maybe Review{NC}")
    someday = storage.list_items(labels=["status/someday"], limit=10)
    someday = [item for item in someday if not item.is_inbox]
    if someday:
        for item in someday:
            print(format_item(item))
        print("\n  Move any to active? Delete stale items?")
    else:
        print("  (none)")

    # 5. Prompts
    print(f"\n{BOLD}5. Reflection Questions{NC}")
    print("  ‚Ä¢ What did I accomplish this quarter?")
    print("  ‚Ä¢ What didn't get done? Why?")
    print("  ‚Ä¢ What do I want to focus on next quarter?")
    print("  ‚Ä¢ Are my goals still aligned with my vision?")

    # Mark quarterly review as complete and log to history
    mark_review_complete("quarterly")
    log_action("review", review_type="quarterly")
    print(f"\n{GREEN}‚úì Quarterly review marked complete{NC}")

    print()
    return 0


def cmd_yearly(args) -> int:
    """Yearly review workflow."""
    storage = get_storage(args.repo, args.backend)

    print(f"\n{BLUE}üéØ Yearly Review{NC}")
    print("=" * 40)

    # 1. Review goals
    print(f"\n{BOLD}1. Goals (horizon/goal){NC}")
    goals = storage.list_items(labels=["horizon/goal"], state="all", limit=30)
    open_goals = [g for g in goals if g.state == "open"]
    closed_goals = [g for g in goals if g.state == "closed"]

    if closed_goals:
        print(f"\n  {GREEN}Completed goals:{NC}")
        for item in closed_goals:
            print(f"    ‚úì #{item.id} {item.title}")

    if open_goals:
        print("\n  Open goals:")
        for item in open_goals:
            print(format_item(item))

    # 2. Projects completed
    print(f"\n{BOLD}2. Projects Completed{NC}")
    milestones = storage.list_milestones(state="closed")
    if milestones:
        for m in milestones:
            title = m.get("title", "Untitled")
            closed_issues = m.get("closed_issues", 0)
            print(f"  ‚úì {title} ({closed_issues} actions completed)")
    else:
        print("  No completed projects this year.")

    # 3. Higher horizons prompts
    print(f"\n{BOLD}3. Higher Horizons Review{NC}")
    print(f"  See {BOLD}references/horizons.md{NC} for your:")
    print("  ‚Ä¢ Areas of Focus (H2)")
    print("  ‚Ä¢ Vision (H4)")
    print("  ‚Ä¢ Purpose & Principles (H5)")

    # 4. Reflection questions
    print(f"\n{BOLD}4. Yearly Reflection Questions{NC}")
    print("  ‚Ä¢ What were my biggest wins this year?")
    print("  ‚Ä¢ What lessons did I learn?")
    print("  ‚Ä¢ What do I want to accomplish next year?")
    print("  ‚Ä¢ Is my vision still inspiring?")
    print("  ‚Ä¢ Are my areas of focus balanced?")

    # 5. Next year setup
    print(f"\n{BOLD}5. Set Up Next Year{NC}")
    print("  1. Archive or close completed goals")
    print("  2. Create new goals for next year")
    print("  3. Define projects to achieve those goals")
    print(f"  Example: {BOLD}gtd add 'Achieve Python mastery' --horizon goal{NC}")

    # Mark yearly review as complete and log to history
    mark_review_complete("yearly")
    log_action("review", review_type="yearly")
    print(f"\n{GREEN}‚úì Yearly review marked complete{NC}")

    print()
    return 0


def cmd_reviews(args) -> int:
    """Show detailed review status."""
    review_status = get_review_status()

    print(f"\n{BLUE}üîÑ Review Status{NC}")
    print("=" * 40)

    for rtype in ["daily", "weekly", "quarterly", "yearly"]:
        status = review_status[rtype]
        print()
        if status["overdue"]:
            if status["days_ago"] is None:
                print(f"  {RED}‚ö† {rtype.title()}{NC}")
                print("    Last done: never")
                print(f"    Status: {RED}OVERDUE{NC}")
            else:
                days_overdue = -status["due_in"]
                print(f"  {RED}‚ö† {rtype.title()}{NC}")
                print(f"    Last done: {status['days_ago']} days ago")
                print(f"    Status: {RED}{days_overdue} days overdue{NC}")
        else:
            if status["days_ago"] == 0:
                print(f"  {GREEN}‚úì {rtype.title()}{NC}")
                print("    Last done: today")
                print(f"    Next due: in {status['due_in']} days")
            else:
                print(f"  {GREEN}‚úì {rtype.title()}{NC}")
                print(f"    Last done: {status['days_ago']} days ago")
                print(f"    Next due: in {status['due_in']} days")

        # Show workflow path
        print(f"    üìñ Agent guide: .claude/skills/gtd/references/{rtype}-review.md")

    # Handle reset if requested
    if hasattr(args, "reset") and args.reset:
        reset_review(args.reset)
        print(f"\n{GREEN}‚úì{NC} Reset {args.reset} review timestamp (for testing)")

    print()
    return 0


def cmd_history(args) -> int:
    """Show action history."""
    from datetime import date as date_type

    # Parse since date if provided
    since = None
    if hasattr(args, "since") and args.since:
        try:
            since = date_type.fromisoformat(args.since)
        except ValueError:
            print(f"{RED}Error:{NC} Invalid date format. Use YYYY-MM-DD.")
            return 1

    # Get limit
    limit = getattr(args, "limit", 20) or 20

    # Read history
    entries = read_history(limit=limit, since=since)

    if not entries:
        print("No history entries found.")
        return 0

    # Output format
    if hasattr(args, "json") and args.json:
        # Raw JSONL output
        import json as json_mod

        for entry in entries:
            print(json_mod.dumps(entry.to_dict()))
    else:
        # Human-readable output
        print(f"\n{BLUE}üìú Action History{NC}")
        print("=" * 40)
        print()
        for entry in entries:
            print(f"  {format_entry_human(entry)}")
        print()

    return 0


# GTD workaround commands (defer, waiting, due, blocked)


def cmd_defer(args) -> int:
    """Defer an item until a future date.

    Usage: gtd defer <id> <date>
    Example: gtd defer 42 2026-03-01
    """
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    # Parse date
    try:
        defer_date = date.fromisoformat(args.date)
    except ValueError:
        print(f"{RED}Error:{NC} Invalid date format. Use YYYY-MM-DD.")
        return 1

    if defer_date <= date.today():
        print(f"{YELLOW}Warning:{NC} Defer date is today or in the past.")

    # Update metadata
    metadata = item.metadata
    new_metadata = GTDMetadata(
        due=metadata.due,
        defer_until=defer_date,
        waiting_for=metadata.waiting_for,
        blocked_by=metadata.blocked_by,
    )
    storage.update_metadata(args.id, new_metadata)

    # Optionally set status to someday
    if args.someday:
        storage.remove_labels(args.id, ["status/active", "status/waiting"])
        storage.add_labels(args.id, ["status/someday"])

    log_action(
        "defer",
        item_id=args.id,
        title=item.title,
        defer_until=defer_date.isoformat(),
        someday=args.someday,
    )
    print(f"{GREEN}‚úì{NC} Deferred #{item.id} until {defer_date}")
    if args.someday:
        print("  Status changed to someday")
    print(f"  Item will resurface after {defer_date}")
    return 0


def cmd_waiting(args) -> int:
    """Mark an item as waiting on someone.

    Usage: gtd waiting <id> <person> [reason]
    Example: gtd waiting 42 Alice "PR review"

    Note: Does NOT use @mentions to avoid notifications.
    """
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    # Update metadata
    metadata = item.metadata
    new_metadata = GTDMetadata(
        due=metadata.due,
        defer_until=metadata.defer_until,
        waiting_for={
            "person": args.person,
            "reason": args.reason or "",
        },
        blocked_by=metadata.blocked_by,
    )
    storage.update_metadata(args.id, new_metadata)

    # Set status to waiting
    storage.remove_labels(args.id, ["status/active", "status/someday"])
    storage.add_labels(args.id, ["status/waiting"])

    log_action(
        "waiting",
        item_id=args.id,
        title=item.title,
        waiting_for=args.person,
        reason=args.reason,
    )
    print(f"{GREEN}‚úì{NC} #{item.id} now waiting on {args.person}")
    if args.reason:
        print(f"  Reason: {args.reason}")
    return 0


def cmd_due(args) -> int:
    """Set or view due date for an item.

    Usage:
      gtd due <id> <date>     # Set due date
      gtd due <id> --clear    # Remove due date
      gtd due <id>            # View due date
    """
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    if args.clear:
        metadata = item.metadata
        new_metadata = GTDMetadata(
            due=None,
            defer_until=metadata.defer_until,
            waiting_for=metadata.waiting_for,
            blocked_by=metadata.blocked_by,
        )
        storage.update_metadata(args.id, new_metadata)
        log_action("due", item_id=args.id, title=item.title, due_date="cleared")
        print(f"{GREEN}‚úì{NC} Cleared due date for #{item.id}")
        return 0

    if not args.date:
        # View mode
        if item.due:
            days_until = (item.due - date.today()).days
            if days_until < 0:
                print(f"{RED}Due:{NC} {item.due} ({abs(days_until)} days overdue)")
            elif days_until == 0:
                print(f"{YELLOW}Due:{NC} {item.due} (TODAY)")
            else:
                print(f"Due: {item.due} ({days_until} days)")
        else:
            print("No due date set.")
        return 0

    # Set due date
    try:
        due_date = date.fromisoformat(args.date)
    except ValueError:
        print(f"{RED}Error:{NC} Invalid date format. Use YYYY-MM-DD.")
        return 1

    metadata = item.metadata
    new_metadata = GTDMetadata(
        due=due_date,
        defer_until=metadata.defer_until,
        waiting_for=metadata.waiting_for,
        blocked_by=metadata.blocked_by,
    )
    storage.update_metadata(args.id, new_metadata)
    log_action("due", item_id=args.id, title=item.title, due_date=due_date.isoformat())

    days_until = (due_date - date.today()).days
    print(f"{GREEN}‚úì{NC} Set due date for #{item.id}: {due_date}")
    if days_until < 0:
        print(f"  {RED}Warning:{NC} Date is in the past!")
    elif days_until == 0:
        print(f"  {YELLOW}Due today!{NC}")
    else:
        print(f"  {days_until} days from now")
    return 0


def cmd_blocked(args) -> int:
    """Mark an item as blocked by other items.

    Usage:
      gtd blocked <id> <blocker-ids>   # Set blockers (comma-separated)
      gtd blocked <id> --clear         # Remove all blockers
      gtd blocked <id>                 # View blockers
    """
    storage = get_storage(args.repo, args.backend)
    item = storage.get_item(args.id)

    if not item:
        print(f"{RED}Error:{NC} Item #{args.id} not found.")
        return 1

    if args.clear:
        metadata = item.metadata
        new_metadata = GTDMetadata(
            due=metadata.due,
            defer_until=metadata.defer_until,
            waiting_for=metadata.waiting_for,
            blocked_by=[],
        )
        storage.update_metadata(args.id, new_metadata)
        storage.remove_labels(args.id, ["status/waiting"])
        storage.add_labels(args.id, ["status/active"])
        log_action("blocked", item_id=args.id, title=item.title, blocked_by="cleared")
        print(f"{GREEN}‚úì{NC} Cleared blockers for #{item.id}")
        return 0

    if not args.blockers:
        # View mode - show blockers from metadata
        blockers = item.blocked_by
        if blockers:
            print(f"{BLUE}Blocked by:{NC}")
            for blocker_id in blockers:
                blocker = storage.get_item(str(blocker_id))
                if blocker:
                    state_color = GREEN if blocker.state == "closed" else YELLOW
                    state_icon = "‚úì" if blocker.state == "closed" else "‚óã"
                    print(
                        f"  {state_icon} #{blocker_id} "
                        f"[{state_color}{blocker.state}{NC}] {blocker.title}"
                    )
                else:
                    print(f"  ? #{blocker_id} (not found)")

            # Check if all blockers are resolved
            all_resolved = True
            for bid in blockers:
                blocker_item = storage.get_item(str(bid))
                if not blocker_item or blocker_item.state != "closed":
                    all_resolved = False
                    break
            if all_resolved and blockers:
                print(f"\n{GREEN}All blockers resolved!{NC}")
                print(f"  Consider: {BOLD}gtd blocked {args.id} --clear{NC}")
        else:
            print("No blockers set.")
        return 0

    # Set blockers
    try:
        blocker_ids = [int(x.strip()) for x in args.blockers.split(",")]
    except ValueError:
        print(f"{RED}Error:{NC} Invalid blocker IDs.")
        print("  Use comma-separated numbers (e.g., 42,43,44).")
        return 1

    # Validate blockers exist
    for bid in blocker_ids:
        if not storage.get_item(str(bid)):
            print(f"{YELLOW}Warning:{NC} Blocker #{bid} not found.")

    metadata = item.metadata
    new_metadata = GTDMetadata(
        due=metadata.due,
        defer_until=metadata.defer_until,
        waiting_for=metadata.waiting_for,
        blocked_by=blocker_ids,
    )
    storage.update_metadata(args.id, new_metadata)

    # Set status to waiting
    storage.remove_labels(args.id, ["status/active", "status/someday"])
    storage.add_labels(args.id, ["status/waiting"])

    log_action("blocked", item_id=args.id, title=item.title, blocked_by=blocker_ids)
    blockers_str = ", ".join(f"#{x}" for x in blocker_ids)
    print(f"{GREEN}‚úì{NC} #{item.id} now blocked by: {blockers_str}")
    return 0


# Project management commands


def cmd_project_list(args) -> int:
    """List all projects with progress."""
    # Reuse existing projects command logic
    return cmd_projects(args)


def cmd_project_show(args) -> int:
    """Show project details and its actions."""
    storage = get_storage(args.repo, args.backend)
    title = " ".join(args.title) if isinstance(args.title, list) else args.title

    milestone = storage.get_milestone(title)
    if not milestone:
        print(f"{RED}Error:{NC} Project '{title}' not found.")
        return 1

    # Display project info
    print(f"\n{BLUE}üìä Project: {BOLD}{milestone.get('title')}{NC}")
    print("=" * 40)

    if milestone.get("description"):
        print(f"\n{milestone.get('description')}")

    if milestone.get("due_on"):
        due = milestone["due_on"][:10]
        print(f"\nDue: {due}")

    # Progress
    open_issues = milestone.get("open_issues", 0)
    closed_issues = milestone.get("closed_issues", 0)
    total = open_issues + closed_issues

    if total > 0:
        pct = int((closed_issues / total) * 100)
        bar_len = 20
        filled = int(bar_len * closed_issues / total)
        bar = "‚ñà" * filled + "‚ñë" * (bar_len - filled)
        print(f"\nProgress: [{bar}] {pct}% ({closed_issues}/{total})")
    else:
        print("\nNo actions yet")

    # List actions in this project
    print(f"\n{BOLD}Actions:{NC}")
    items = storage.list_items(project=title, state="all", limit=50)
    if items:
        open_items = [i for i in items if i.state == "open"]
        closed_items = [i for i in items if i.state == "closed"]

        if open_items:
            print(f"\n  {YELLOW}Open ({len(open_items)}):{NC}")
            for item in open_items:
                print(format_item(item, show_labels=True))

        if closed_items:
            print(f"\n  {GREEN}Completed ({len(closed_items)}):{NC}")
            for item in closed_items[:5]:  # Show last 5 completed
                print(f"    ‚úì #{item.id} {item.title}")
            if len(closed_items) > 5:
                print(f"    ... and {len(closed_items) - 5} more")
    else:
        print("  (none)")

    print()
    return 0


def cmd_project_create(args) -> int:
    """Create a new project."""
    storage = get_storage(args.repo, args.backend)
    title = " ".join(args.title)

    # Check if already exists
    existing = storage.get_milestone(title)
    if existing:
        print(f"{YELLOW}‚ö†{NC} Project '{title}' already exists.")
        return 1

    milestone = storage.create_milestone(
        title=title,
        description=args.desc,
        due_on=args.due,
    )
    log_action("project_create", project=title, due=args.due)
    print(f"{GREEN}‚úì{NC} Created project: {milestone.get('title')}")
    if args.due:
        print(f"  Due: {args.due}")
    return 0


def cmd_project_update(args) -> int:
    """Update a project."""
    storage = get_storage(args.repo, args.backend)
    title = " ".join(args.title) if isinstance(args.title, list) else args.title

    # Check if any update was requested
    if not any([args.desc, args.due, args.state, args.rename]):
        print(
            f"{YELLOW}‚ö†{NC} No updates specified. Use --desc, --due, "
            f"--state, or --rename."
        )
        return 1

    # If renaming, we need special handling (GitHub API doesn't rename directly)
    if args.rename:
        milestone = storage.get_milestone(title)
        if not milestone:
            print(f"{RED}Error:{NC} Project '{title}' not found.")
            return 1
        # Update title via PATCH
        number = milestone.get("number")
        storage._run_gh(
            [
                "api",
                f"repos/:owner/:repo/milestones/{number}",
                "-X",
                "PATCH",
                "-f",
                f"title={args.rename}",
            ]
        )
        print(f"{GREEN}‚úì{NC} Renamed project: {title} ‚Üí {args.rename}")
        title = args.rename  # Use new name for further updates

    result = storage.update_milestone(
        title,
        description=args.desc,
        due_on=args.due,
        state=args.state,
    )

    if not result:
        print(f"{RED}Error:{NC} Project '{title}' not found.")
        return 1

    orig_title = args.title
    if isinstance(orig_title, list):
        orig_title = " ".join(orig_title)
    log_action(
        "project_update",
        project=title,
        renamed_from=orig_title if args.rename else None,
        due=args.due,
        state=args.state,
    )
    print(f"{GREEN}‚úì{NC} Updated project: {title}")
    if args.desc:
        print("  Description updated")
    if args.due:
        print(f"  Due: {args.due}")
    if args.state:
        print(f"  State: {args.state}")
    return 0


def cmd_project_delete(args) -> int:
    """Delete a project."""
    storage = get_storage(args.repo, args.backend)
    title = " ".join(args.title) if isinstance(args.title, list) else args.title

    milestone = storage.get_milestone(title)
    if not milestone:
        print(f"{RED}Error:{NC} Project '{title}' not found.")
        return 1

    open_issues = milestone.get("open_issues", 0)

    # Warn if there are open issues
    if open_issues > 0 and not args.force:
        print(f"{YELLOW}‚ö†{NC} Project '{title}' has {open_issues} open action(s).")
        print(f"  Use {BOLD}--force{NC} to delete anyway.")
        print("  (Actions will be unassigned from the project, not deleted)")
        return 1

    if storage.delete_milestone(title):
        log_action("project_delete", project=title, orphaned_items=open_issues)
        print(f"{GREEN}‚úì{NC} Deleted project: {title}")
        if open_issues > 0:
            print(f"  {open_issues} action(s) are now unassigned")
        return 0
    else:
        print(f"{RED}Error:{NC} Failed to delete project.")
        return 1


def _check_tool(cmd: str) -> bool:
    """Check if a CLI tool is available in PATH."""
    import shutil

    return shutil.which(cmd) is not None


def _show_init_prompt() -> int:
    """Show the initialization prompt (only time we reveal backends)."""
    gh_ok = _check_tool("gh")
    task_ok = _check_tool("task")

    print(f"{BLUE}GTD CLI{NC} - Getting Things Done task management")
    print()
    print(f"{YELLOW}!{NC} No .gtd/config.json found. Choose a storage backend:")
    print()

    # GitHub option
    gh_status = f"{GREEN}‚úì ready{NC}" if gh_ok else f"{RED}‚úó not found{NC}"
    print(f"  {BOLD}gtd init github{NC}      - Store tasks as GitHub Issues")
    print(f"                         gh CLI: {gh_status}")
    if not gh_ok:
        print(f"                         Install: {BOLD}brew install gh{NC}")
    print()

    # Taskwarrior option
    task_status = f"{GREEN}‚úì ready{NC}" if task_ok else f"{RED}‚úó not found{NC}"
    print(f"  {BOLD}gtd init taskwarrior{NC} - Store tasks locally")
    print(f"                         task CLI: {task_status}")
    if not task_ok:
        print(f"                         Install: {BOLD}brew install task{NC}")
    print()

    print(f"Run {BOLD}gtd init{NC} for more details on each option.")
    return 1


def main() -> int:
    # Check initialization state BEFORE building parser
    initialized = is_initialized()

    # Commands that don't require storage initialization
    storage_free_commands = {"init", "reviews", "history"}

    # If not initialized, handle specially
    if not initialized:
        # Allow storage-free commands through, show prompt for everything else
        if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help"):
            return _show_init_prompt()
        if sys.argv[1] not in storage_free_commands:
            # Pattern 3: Wrong-directory detection
            if detect_skill_directory():
                print(
                    f"{RED}Error:{NC} Running from the skill directory, not a project."
                )
                print("  Call the script with its full path from your project root.")
                return 1
            return _show_init_prompt()

    parser = argparse.ArgumentParser(
        description="GTD CLI - Getting Things Done task management",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    # Hidden: backend-specific options (not shown in --help)
    parser.add_argument(
        "--repo",
        help=argparse.SUPPRESS,  # GitHub-specific, hidden
    )
    parser.add_argument(
        "--backend",
        choices=["github", "taskwarrior"],
        help=argparse.SUPPRESS,  # Use `gtd init` instead
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to run")

    # init - always available; behavior depends on initialization state
    init_help = (
        "Initialize GTD with a storage backend"
        if not initialized
        else "Initialize or reconfigure GTD with a storage backend"
    )
    p = subparsers.add_parser("init", help=init_help)
    p.add_argument(
        "backend_choice",
        nargs="?",
        help="Backend to use (run without args to see options)",
    )
    p.add_argument(
        "--force",
        action="store_true",
        help=argparse.SUPPRESS,  # Hidden: only revealed in output
    )
    p.set_defaults(func=cmd_init)

    # capture
    p = subparsers.add_parser("capture", help="Quick capture to inbox")
    p.add_argument("text", nargs="+", help="Text to capture")
    p.add_argument("--body", "-b", help="Additional notes")
    p.set_defaults(func=cmd_capture)

    # inbox
    p = subparsers.add_parser("inbox", help="List inbox items needing clarification")
    p.set_defaults(func=cmd_inbox)

    # clarify
    p = subparsers.add_parser(
        "clarify",
        help="Clarify an inbox item (requires flags)",
    )
    p.add_argument("id", help="Item ID")
    # Non-actionable path
    p.add_argument(
        "--not-actionable",
        action="store_true",
        dest="not_actionable",
        help="Item is not actionable (use with --delete, --someday, or --reference)",
    )
    p.add_argument("--delete", action="store_true", help="Delete non-actionable item")
    p.add_argument(
        "--someday", action="store_true", help="Keep non-actionable in someday/maybe"
    )
    p.add_argument(
        "--reference",
        action="store_true",
        help="Non-actionable reference (move to notes)",
    )
    # Actionable path (using any of these implies actionable)
    p.add_argument("--outcome", help="What 'done' looks like")
    p.add_argument(
        "--next-action", dest="next_action", help="Update title to next action"
    )
    p.add_argument(
        "--status", "-s", choices=STATUSES, help="Set status (default: active)"
    )
    p.add_argument("--context", "-c", choices=CONTEXTS, help="Set context")
    p.add_argument("--energy", "-e", choices=ENERGIES, help="Set energy level")
    p.add_argument(
        "--horizon", "-H", choices=HORIZONS, help="Set horizon (default: action)"
    )
    p.add_argument("--project", "-p", help="Assign to project")
    p.set_defaults(func=cmd_clarify)

    # add
    p = subparsers.add_parser("add", help="Add a clarified task")
    p.add_argument("title", nargs="+", help="Task title")
    p.add_argument("--body", "-b", help="Task body")
    p.add_argument("--context", "-c", choices=CONTEXTS, help="Context")
    p.add_argument("--energy", "-e", choices=ENERGIES, help="Energy level")
    p.add_argument(
        "--status", "-s", choices=STATUSES, help="Status (active/waiting/someday)"
    )
    p.add_argument(
        "--horizon", "-H", choices=HORIZONS, help="Horizon (action/project/goal)"
    )
    p.add_argument(
        "--project", "-p", help="Project to assign this to (e.g., 'Launch MVP')"
    )
    p.set_defaults(func=cmd_add)

    # list
    p = subparsers.add_parser("list", help="List tasks")
    p.add_argument("--context", "-c", choices=CONTEXTS, help="Filter by context")
    p.add_argument("--energy", "-e", choices=ENERGIES, help="Filter by energy")
    p.add_argument("--status", "-s", choices=STATUSES, help="Filter by status")
    p.add_argument("--horizon", "-H", choices=HORIZONS, help="Filter by horizon")
    p.add_argument("--project", "-p", help="Filter by project")
    p.add_argument(
        "--state", choices=["open", "closed", "all"], default="open", help="Item state"
    )
    p.add_argument("--limit", "-l", type=int, default=100, help="Max items")
    p.add_argument("--raw", "-r", action="store_true", help="Raw list (no grouping)")
    p.add_argument("--verbose", "-v", action="store_true", help="Show debug output")
    # Date-based filters (GTD workarounds)
    p.add_argument("--due-before", help="Filter: due on or before date (YYYY-MM-DD)")
    p.add_argument("--overdue", action="store_true", help="Filter: past due date")
    p.add_argument("--deferred", action="store_true", help="Filter: currently deferred")
    p.add_argument("--not-deferred", action="store_true", help="Filter: not deferred")
    p.add_argument("--blocked", action="store_true", help="Filter: has blockers")
    p.add_argument("--waiting-on", help="Filter: waiting on person (partial match)")
    p.set_defaults(func=cmd_list)

    # done
    p = subparsers.add_parser("done", help="Mark task complete")
    p.add_argument("id", help="Item ID")
    p.add_argument("--comment", "-m", help="Add completion comment")
    p.set_defaults(func=cmd_done)

    # update
    p = subparsers.add_parser("update", help="Update task GTD labels")
    p.add_argument("id", help="Item ID")
    p.add_argument("--status", "-s", choices=STATUSES, help="Set status")
    p.add_argument("--context", "-c", choices=CONTEXTS, help="Set context")
    p.add_argument("--energy", "-e", choices=ENERGIES, help="Set energy")
    p.add_argument("--horizon", "-H", choices=HORIZONS, help="Set horizon")
    p.add_argument("--project", "-p", help="Set project")
    p.set_defaults(func=cmd_update)

    # comment
    p = subparsers.add_parser("comment", help="Add comment to task")
    p.add_argument("id", help="Item ID")
    p.add_argument("message", nargs="+", help="Comment message")
    p.set_defaults(func=cmd_comment)

    # view
    p = subparsers.add_parser("view", help="View task with GTD info")
    p.add_argument("id", help="Item ID")
    p.set_defaults(func=cmd_view)

    # bulk
    p = subparsers.add_parser("bulk", help="Bulk operations on multiple tasks")
    p.add_argument("ids", help="Item IDs (comma-separated, or ranges like 1-5)")
    p.add_argument("--status", "-s", choices=STATUSES, help="Set status")
    p.add_argument("--context", "-c", choices=CONTEXTS, help="Set context")
    p.add_argument("--energy", "-e", choices=ENERGIES, help="Set energy")
    p.add_argument("--horizon", "-H", choices=HORIZONS, help="Set horizon")
    p.add_argument("--project", "-p", help="Set project")
    p.add_argument("--add-label", help="Add a label")
    p.add_argument("--remove-label", help="Remove a label")
    p.add_argument("--close", action="store_true", help="Close items")
    p.add_argument(
        "--force", "-f", action="store_true", help=argparse.SUPPRESS
    )  # Hidden: revealed in output
    p.set_defaults(func=cmd_bulk)

    # next
    p = subparsers.add_parser("next", help="Show the next action to work on")
    p.add_argument("--context", "-c", choices=CONTEXTS, help="Filter by context")
    p.add_argument("--energy", "-e", choices=ENERGIES, help="Filter by energy")
    p.set_defaults(func=cmd_next)

    # daily
    p = subparsers.add_parser("daily", help="Daily review")
    p.set_defaults(func=cmd_daily)

    # weekly
    p = subparsers.add_parser("weekly", help="Weekly review")
    p.set_defaults(func=cmd_weekly)

    # setup
    p = subparsers.add_parser("setup", help="Set up storage backend (create labels)")
    # --check and --cleanup are mutually exclusive modes
    mode_group = p.add_mutually_exclusive_group()
    mode_group.add_argument(
        "--check", action="store_true", help="Detailed status check"
    )
    mode_group.add_argument(
        "--cleanup",
        action="store_true",
        help="Preview stale label removal",
    )
    # --force modifies behavior (fix drift in setup mode, execute in cleanup mode)
    # Hidden from help - revealed in command output
    p.add_argument(
        "--force",
        "-f",
        action="store_true",
        help=argparse.SUPPRESS,
    )
    p.set_defaults(func=cmd_setup)

    # projects
    p = subparsers.add_parser("projects", help="List all projects with progress")
    p.add_argument(
        "--state", "-s", choices=["open", "closed", "all"], default="open", help="State"
    )
    p.set_defaults(func=cmd_projects)

    # quarterly
    p = subparsers.add_parser("quarterly", help="Quarterly review")
    p.set_defaults(func=cmd_quarterly)

    # yearly
    p = subparsers.add_parser("yearly", help="Yearly review")
    p.set_defaults(func=cmd_yearly)

    # reviews - detailed review status
    p = subparsers.add_parser("reviews", help="Show detailed review status")
    p.add_argument(
        "--reset",
        choices=["daily", "weekly", "quarterly", "yearly"],
        help="Reset a review timestamp (for testing)",
    )
    p.set_defaults(func=cmd_reviews)

    # history - action history
    p = subparsers.add_parser("history", help="Show action history")
    p.add_argument("--limit", "-l", type=int, default=20, help="Max entries to show")
    p.add_argument("--since", help="Only show entries since date (YYYY-MM-DD)")
    p.add_argument(
        "--json", action="store_true", help="Output as raw JSONL (machine-readable)"
    )
    p.set_defaults(func=cmd_history)

    # defer - GTD workaround for deferred items
    p = subparsers.add_parser("defer", help="Defer an item until a future date")
    p.add_argument("id", help="Item ID")
    p.add_argument("date", help="Defer until date (YYYY-MM-DD)")
    p.add_argument(
        "--someday", "-s", action="store_true", help="Also set status to someday"
    )
    p.set_defaults(func=cmd_defer)

    # waiting - GTD workaround for tracking who you're waiting on
    p = subparsers.add_parser("waiting", help="Mark item as waiting on someone")
    p.add_argument("id", help="Item ID")
    p.add_argument("person", help="Person you're waiting on (NO @mentions)")
    p.add_argument("reason", nargs="?", help="What you're waiting for")
    p.set_defaults(func=cmd_waiting)

    # due - GTD workaround for due dates
    p = subparsers.add_parser("due", help="Set or view due date")
    p.add_argument("id", help="Item ID")
    p.add_argument("date", nargs="?", help="Due date (YYYY-MM-DD)")
    p.add_argument("--clear", action="store_true", help="Remove due date")
    p.set_defaults(func=cmd_due)

    # blocked - GTD workaround for dependencies
    p = subparsers.add_parser("blocked", help="Mark item as blocked by other items")
    p.add_argument("id", help="Item ID")
    p.add_argument("blockers", nargs="?", help="Blocker IDs (comma-separated)")
    p.add_argument("--clear", action="store_true", help="Remove all blockers")
    p.set_defaults(func=cmd_blocked)

    # project command group
    project_parser = subparsers.add_parser(
        "project", help="Manage projects (milestones)"
    )
    project_sub = project_parser.add_subparsers(
        dest="project_command", help="Project command"
    )

    # project list
    p = project_sub.add_parser("list", help="List projects with progress")
    p.add_argument(
        "--state",
        "-s",
        choices=["open", "closed", "all"],
        default="open",
        help="State filter",
    )
    p.add_argument(
        "--format",
        "-f",
        choices=["pretty", "plain"],
        default="pretty",
        help="Output format: pretty (decorated) or plain (one title per line)",
    )
    p.set_defaults(func=cmd_project_list)

    # project show
    p = project_sub.add_parser("show", help="Show project details and actions")
    p.add_argument("title", nargs="+", help="Project title")
    p.set_defaults(func=cmd_project_show)

    # project create
    p = project_sub.add_parser("create", help="Create a new project")
    p.add_argument("title", nargs="+", help="Project title")
    p.add_argument("--desc", "-d", help="Project description")
    p.add_argument("--due", help="Due date (YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DD)")
    p.set_defaults(func=cmd_project_create)

    # project update
    p = project_sub.add_parser("update", help="Update a project")
    p.add_argument("title", nargs="+", help="Project title")
    p.add_argument("--desc", "-d", help="New description")
    p.add_argument("--due", help="New due date")
    p.add_argument("--state", choices=["open", "closed"], help="New state")
    p.add_argument("--rename", help="Rename project to this title")
    p.set_defaults(func=cmd_project_update)

    # project delete
    p = project_sub.add_parser("delete", help="Delete a project")
    p.add_argument("title", nargs="+", help="Project title")
    p.add_argument(
        "--force", "-f", action="store_true", help=argparse.SUPPRESS
    )  # Hidden: revealed in output when project has open actions
    p.set_defaults(func=cmd_project_delete)

    args = parser.parse_args()

    if not args.command:
        # Default: show status (safe, read-only) ‚Äî NOT help
        return cmd_status(args)

    # Handle 'project' without subcommand - show help
    if args.command == "project" and not args.project_command:
        project_parser.print_help()
        return 1

    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
