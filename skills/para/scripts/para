#!/usr/bin/env python3
"""PARA CLI - Organize notes by actionability (Projects, Areas, Resources, Archive)."""

import argparse
import os
import shutil
import sys
from pathlib import Path

try:
    import tomllib  # Python 3.11+ (project requires >=3.11)
except ImportError:
    tomllib = None  # Defensive fallback for manual TOML parsing

# Config file location (XDG-compliant)
CONFIG_DIR = Path.home() / ".config" / "para"
CONFIG_FILE = CONFIG_DIR / "config.toml"

# ANSI colors
BLUE = "\033[0;34m"
GREEN = "\033[0;32m"
YELLOW = "\033[0;33m"
RED = "\033[0;31m"
BOLD = "\033[1m"
NC = "\033[0m"  # No Color

# PARA folder names
PARA_FOLDERS = {
    "projects": "1_Projects",
    "areas": "2_Areas",
    "resources": "3_Resources",
    "archive": "4_Archive",
}


def load_config() -> dict:
    """Load config from ~/.config/para/config.toml.

    Config structure:
        para_root = "/default/para/path"  # Global default

        [repos]
        "/path/to/repo-a" = "/path/to/para-for-a"
        "/path/to/repo-b" = "/path/to/para-for-b"
    """
    if not CONFIG_FILE.exists():
        return {}

    content = CONFIG_FILE.read_text()

    if tomllib:
        return tomllib.loads(content)

    # Fallback: simple TOML parsing
    config = {}
    current_section = None
    for line in content.splitlines():
        line = line.strip()
        if line.startswith("#") or not line:
            continue
        # Section header
        if line.startswith("[") and line.endswith("]"):
            current_section = line[1:-1]
            if current_section not in config:
                config[current_section] = {}
            continue
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        key = key.strip().strip('"').strip("'")
        value = value.strip().strip('"').strip("'")
        if current_section:
            config[current_section][key] = value
        else:
            config[key] = value
    return config


def save_config(config: dict) -> None:
    """Save config to ~/.config/para/config.toml."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    lines = ["# PARA CLI configuration\n"]

    # Write top-level keys first
    for key, value in config.items():
        if not isinstance(value, dict):
            lines.append(f'{key} = "{value}"\n')

    # Write sections
    for key, value in config.items():
        if isinstance(value, dict):
            lines.append(f"\n[{key}]\n")
            for k, v in value.items():
                lines.append(f'"{k}" = "{v}"\n')

    CONFIG_FILE.write_text("".join(lines))


def find_git_root() -> Path | None:
    """Find the root of the current git repository."""
    cwd = Path.cwd()
    for path in [cwd] + list(cwd.parents):
        if (path / ".git").exists():
            return path
    return None


def load_local_config(repo_root: Path) -> dict:
    """Load .para.toml from repo root if it exists.

    Local config structure:
        para_root = "/path/to/para/for/this/repo"
    """
    local_config = repo_root / ".para.toml"
    if not local_config.exists():
        return {}

    content = local_config.read_text()

    if tomllib:
        return tomllib.loads(content)

    # Fallback: simple parsing
    config = {}
    for line in content.splitlines():
        line = line.strip()
        if line.startswith("#") or "=" not in line:
            continue
        key, value = line.split("=", 1)
        config[key.strip()] = value.strip().strip('"').strip("'")
    return config


def detect_skill_directory(cwd: Path | None = None) -> bool:
    """Detect if cwd is the skill directory itself (Pattern 3).

    Checks for a fingerprint of SKILL.md + scripts/ which indicates the user
    is running from the skill's own source directory, not a project.
    """
    cwd = cwd or Path.cwd()
    return all((cwd / f).exists() for f in ["SKILL.md", "scripts"])


def find_para_root() -> Path | None:
    """Find the PARA root directory.

    Resolution order:
    1. Local .para.toml in current git repo root
    2. [repos] mapping in global config (longest prefix match)
    3. Global para_root in config
    4. Auto-discovery: walk up from cwd looking for PARA folders
    """
    cwd = Path.cwd()
    config = load_config()

    # 1. Check for local .para.toml in git repo
    git_root = find_git_root()
    if git_root:
        local_config = load_local_config(git_root)
        if "para_root" in local_config:
            configured_path = Path(local_config["para_root"]).expanduser()
            if configured_path.exists():
                return configured_path

    # 2. Check [repos] mapping (longest prefix match)
    repos = config.get("repos", {})
    if repos and git_root:
        git_root_str = str(git_root)
        # Find longest matching prefix
        best_match = None
        best_len = 0
        for repo_path, para_path in repos.items():
            repo_path_expanded = str(Path(repo_path).expanduser())
            if git_root_str.startswith(repo_path_expanded):
                if len(repo_path_expanded) > best_len:
                    best_match = para_path
                    best_len = len(repo_path_expanded)
        if best_match:
            configured_path = Path(best_match).expanduser()
            if configured_path.exists():
                return configured_path

    # 3. Check global para_root
    if "para_root" in config:
        configured_path = Path(config["para_root"]).expanduser()
        if configured_path.exists():
            return configured_path

    # 4. Fallback: auto-discovery from cwd
    for path in [cwd] + list(cwd.parents):
        if (path / PARA_FOLDERS["projects"]).exists() or (
            path / PARA_FOLDERS["areas"]
        ).exists():
            return path
    return None


def prompt_for_para_root() -> Path | None:
    """Interactively ask user for PARA root and optionally initialize."""
    print(f"\n{BLUE}PARA Setup{NC}")
    print("=" * 40)
    print("No PARA folder structure found and no config set.\n")

    try:
        path_input = input("Enter PARA root directory (or 'q' to quit): ").strip()
    except (EOFError, KeyboardInterrupt):
        print()
        return None

    if not path_input or path_input.lower() == "q":
        return None

    root = Path(path_input).expanduser().resolve()

    # Check if PARA structure exists there
    has_structure = (root / PARA_FOLDERS["projects"]).exists() or (
        root / PARA_FOLDERS["areas"]
    ).exists()

    if not has_structure:
        if not root.exists():
            try:
                create = input("Directory doesn't exist. Create it? [Y/n]: ").strip()
            except (EOFError, KeyboardInterrupt):
                print()
                return None
            if create.lower() == "n":
                return None
            root.mkdir(parents=True, exist_ok=True)

        # Initialize PARA structure
        print(f"\n{BLUE}Initializing PARA structure...{NC}")
        for key, folder in PARA_FOLDERS.items():
            folder_path = root / folder
            if not folder_path.exists():
                folder_path.mkdir(parents=True)
                index_path = folder_path / "_INDEX.md"
                index_path.write_text(f"# {folder}\n\nIndex of {key}.\n")
                print(f"  {GREEN}created:{NC} {folder}")

    # Save to config
    config = load_config()
    config["para_root"] = str(root)
    save_config(config)
    print(f"\n{GREEN}‚úì{NC} Saved to {CONFIG_FILE}")

    return root


def get_para_root() -> Path:
    """Get PARA root, prompt user if not found."""
    root = find_para_root()
    if not root:
        # Pattern 3: Wrong-directory detection before interactive prompt
        if detect_skill_directory():
            print(f"\n{RED}Error:{NC} Running from the skill directory, not a project.")
            print("  Call the script with its full path from your project root.")
            sys.exit(1)
        root = prompt_for_para_root()
        if not root:
            print(f"\n{RED}Error:{NC} PARA root not configured.")
            print(f"  Run {BOLD}para config --set-root /path/to/para{NC}")
            sys.exit(1)
    return root


def get_para_projects(root: Path) -> list[str]:
    """Get list of PARA project folder names."""
    projects_dir = root / PARA_FOLDERS["projects"]
    if not projects_dir.exists():
        return []

    projects = []
    for item in projects_dir.iterdir():
        if item.is_dir() and not item.name.startswith("_"):
            projects.append(item.name)
    return sorted(projects)


def cmd_config(args) -> int:
    """Show or set PARA configuration."""
    config = load_config()

    # Set para_root (global default)
    if args.set_root:
        path = Path(args.set_root).expanduser().resolve()
        if not path.exists():
            print(f"{RED}Error:{NC} Path does not exist: {path}")
            return 1
        config["para_root"] = str(path)
        save_config(config)
        print(f"{GREEN}‚úì{NC} Set para_root = {path}")
        return 0

    # Unset para_root
    if args.unset_root:
        if "para_root" in config:
            del config["para_root"]
            save_config(config)
            print(f"{GREEN}‚úì{NC} Removed para_root from config")
        else:
            print(f"{YELLOW}Note:{NC} para_root was not set")
        return 0

    # Set repo mapping
    if args.set_repo:
        repo_path, para_path = args.set_repo
        repo_path = str(Path(repo_path).expanduser().resolve())
        para_path_resolved = Path(para_path).expanduser().resolve()
        if not para_path_resolved.exists():
            print(f"{RED}Error:{NC} PARA path does not exist: {para_path_resolved}")
            return 1
        if "repos" not in config:
            config["repos"] = {}
        config["repos"][repo_path] = str(para_path_resolved)
        save_config(config)
        print(f"{GREEN}‚úì{NC} Mapped repo {repo_path}")
        print(f"         ‚Üí {para_path_resolved}")
        return 0

    # Unset repo mapping
    if args.unset_repo:
        repo_path = str(Path(args.unset_repo).expanduser().resolve())
        repos = config.get("repos", {})
        if repo_path in repos:
            del repos[repo_path]
            if not repos:
                del config["repos"]
            save_config(config)
            print(f"{GREEN}‚úì{NC} Removed mapping for {repo_path}")
        else:
            print(f"{YELLOW}Note:{NC} No mapping found for {repo_path}")
        return 0

    # Show config
    print(f"\n{BLUE}‚öôÔ∏è  PARA Config{NC}")
    print(f"Config file: {CONFIG_FILE}")
    print("=" * 40)

    # Global default
    if "para_root" in config:
        print(f"\n{BOLD}Default:{NC}")
        print(f"  para_root = {config['para_root']}")
    else:
        print(f"\n{YELLOW}No global default set.{NC}")

    # Repo mappings
    repos = config.get("repos", {})
    if repos:
        print(f"\n{BOLD}Repo mappings:{NC}")
        for repo, para in repos.items():
            print(f"  {repo}")
            print(f"    ‚Üí {para}")
    else:
        print(f"\n{YELLOW}No repo mappings.{NC}")

    # Show resolution context
    git_root = find_git_root()
    print(f"\n{BOLD}Current context:{NC}")
    print(f"  Git repo: {git_root or '(not in a git repo)'}")

    if git_root:
        local_config = load_local_config(git_root)
        local_para = local_config.get("para_root")
        if local_para:
            print(f"  Local .para.toml: {local_para}")
        else:
            print("  Local .para.toml: (none)")

    # Show effective root
    root = find_para_root()
    print(f"\n{GREEN}Effective PARA root:{NC} {root or '(not found)'}")

    if not config and not root:
        print(f"\n{BOLD}Quick start:{NC}")
        print(f"  Global default: {BOLD}para config --set-root /path/to/para{NC}")
        print(f"  For this repo:  {BOLD}para config --set-repo . /path/to/para{NC}")

    return 0


def cmd_init(args) -> int:
    """Initialize PARA folder structure."""
    root = Path(args.path).expanduser().resolve() if args.path else Path.cwd()

    print(f"{BLUE}Initializing PARA structure in {root}{NC}")
    print("=" * 40)

    for key, folder in PARA_FOLDERS.items():
        folder_path = root / folder
        if folder_path.exists():
            print(f"  {YELLOW}exists:{NC} {folder}")
        else:
            folder_path.mkdir(parents=True)
            # Create index file
            index_path = folder_path / "_INDEX.md"
            index_path.write_text(f"# {folder}\n\nIndex of {key}.\n")
            print(f"  {GREEN}created:{NC} {folder}")

    # Save to config if requested
    if args.save_config:
        config = load_config()
        config["para_root"] = str(root)
        save_config(config)
        print(f"{GREEN}‚úì{NC} Saved to {CONFIG_FILE}")

    print(f"\n{GREEN}‚úì{NC} PARA structure ready.")
    return 0


def cmd_status(args) -> int:
    """Show PARA structure status."""
    # Use find_para_root() directly to avoid interactive prompt
    root = find_para_root()
    if not root:
        print(f"{RED}Error:{NC} PARA root not configured.")
        print(f"Run {BOLD}para init --path /path/to/para --save-config{NC} to set up.")
        return 1

    print(f"\n{BLUE}üìÅ PARA Status{NC}")
    print(f"Root: {root}")
    print("=" * 40)

    for key, folder in PARA_FOLDERS.items():
        folder_path = root / folder
        if folder_path.exists():
            items = [
                f
                for f in folder_path.iterdir()
                if not f.name.startswith("_") and not f.name.startswith(".")
            ]
            print(f"\n{BOLD}{folder}{NC} ({len(items)} items)")
            for item in sorted(items)[:10]:  # Show first 10
                if item.is_dir():
                    print(f"  üìÅ {item.name}/")
                else:
                    print(f"  üìÑ {item.name}")
            if len(items) > 10:
                print(f"  ... and {len(items) - 10} more")
        else:
            print(f"\n{YELLOW}{folder}{NC} (not found)")

    return 0


def cmd_project_list(args) -> int:
    """List PARA projects."""
    root = get_para_root()

    para_projects = list(get_para_projects(root))

    print(f"\n{BLUE}üìÅ PARA Projects{NC}")
    print("=" * 40)

    if not para_projects:
        print("\nNo PARA projects found.")
        print(f"\nCreate one with: {BOLD}para project create 'Project-Name'{NC}")
        return 0

    for p in sorted(para_projects):
        print(f"  üìÅ {p}")

    return 0


def _validate_project_name(name: str) -> str | None:
    """Validate project name against path traversal. Returns error message or None."""
    if os.sep in name or (os.altsep and os.altsep in name) or "/" in name:
        return "Invalid project name: must not contain path separators"
    if name in (".", "..") or name.startswith(".."):
        return "Invalid project name: must not be a relative path"
    return None


def cmd_project_create(args) -> int:
    """Create a new PARA project folder."""
    root = get_para_root()
    name = args.name

    if err := _validate_project_name(name):
        print(f"{RED}Error:{NC} {err}")
        return 1

    # Create PARA folder
    folder_path = root / PARA_FOLDERS["projects"] / name
    if folder_path.exists():
        print(f"{YELLOW}Warning:{NC} Project folder already exists: {folder_path}")
        return 0

    folder_path.mkdir(parents=True)
    index_content = f"""# Project: {name}

## Outcome
[What does "done" look like?]

## Status
- [x] Active

## Key Files
- [List important files here]

## Notes
"""
    (folder_path / "_INDEX.md").write_text(index_content)
    print(f"{GREEN}‚úì{NC} Created PARA project: {folder_path}")

    return 0


def cmd_project_archive(args) -> int:
    """Archive a PARA project."""
    root = get_para_root()
    name = args.name

    if err := _validate_project_name(name):
        print(f"{RED}Error:{NC} {err}")
        return 1

    # Find the project folder
    project_path = root / PARA_FOLDERS["projects"] / name
    if not project_path.exists():
        print(f"{RED}Error:{NC} Project not found: {project_path}")
        return 1

    # Create archive destination
    archive_dest = root / PARA_FOLDERS["archive"] / "projects"
    archive_dest.mkdir(parents=True, exist_ok=True)

    # Move to archive
    dest_path = archive_dest / name
    if dest_path.exists():
        print(f"{RED}Error:{NC} Archive destination already exists: {dest_path}")
        return 1

    shutil.move(str(project_path), str(dest_path))
    print(f"{GREEN}‚úì{NC} Archived: {project_path} ‚Üí {dest_path}")

    return 0


def main():
    parser = argparse.ArgumentParser(
        description="PARA CLI - Organize notes and files by actionability.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
PARA Method Overview:
  Projects   - Active work with defined outcomes and deadlines
  Areas      - Ongoing responsibilities without end dates
  Resources  - Reference materials for future use
  Archive    - Completed or inactive items

Configuration Resolution (in order):
  1. Local .para.toml in current git repo root
  2. [repos] mapping in ~/.config/para/config.toml (longest prefix match)
  3. Global para_root in ~/.config/para/config.toml
  4. Auto-discovery: walk up from cwd looking for PARA folders

Quick Start Examples:
  # Initialize PARA in a new directory and save to config
  para init --path ~/Notes/para --save-config

  # Check current PARA status
  para status

  # Create a new project folder
  para project create "My-New-Project"

  # List all projects
  para project list

For LLM Integration:
  - Use 'para status' to discover the current PARA root and structure
  - Use 'para config' to inspect resolution context and repo mappings
  - Project names should use kebab-case or PascalCase (no spaces)
  - The CLI outputs colored text; parse the semantic content, not colors
""",
    )
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # config
    p_config = subparsers.add_parser(
        "config",
        help="Show or set PARA configuration",
        description=(
            "Manage PARA configuration. Shows current config when called "
            "without arguments."
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Show current configuration and resolution context
  para config

  # Set a global default PARA root (used when no repo mapping matches)
  para config --set-root ~/Notes/para

  # Map current git repo to a specific PARA root
  para config --set-repo . ~/Notes/work-para

  # Map a specific repo path to a PARA root
  para config --set-repo ~/Projects/myapp ~/Notes/myapp-para

  # Remove a repo mapping
  para config --unset-repo ~/Projects/myapp

Output Fields (for LLM parsing):
  - "Effective PARA root:" shows the resolved path that will be used
  - "Git repo:" shows the current git repository context
  - "Local .para.toml:" shows per-repo override if present
""",
    )
    p_config.add_argument(
        "--set-root",
        metavar="PATH",
        help="Set global default PARA root (must exist)",
    )
    p_config.add_argument(
        "--unset-root",
        action="store_true",
        help="Remove global para_root from config",
    )
    p_config.add_argument(
        "--set-repo",
        nargs=2,
        metavar=("REPO", "PARA"),
        help=(
            "Map a git repo to a PARA root. REPO can be '.' for current "
            "repo. PARA path must exist."
        ),
    )
    p_config.add_argument(
        "--unset-repo",
        metavar="REPO",
        help="Remove repo mapping. REPO can be '.' for current repo.",
    )
    p_config.set_defaults(func=cmd_config)

    # init
    p_init = subparsers.add_parser(
        "init",
        help="Initialize PARA folder structure",
        description=(
            "Create the standard PARA folder structure (1_Projects, 2_Areas, "
            "3_Resources, 4_Archive)."
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Initialize PARA in current directory
  para init

  # Initialize PARA in a specific path
  para init --path ~/Notes/para

  # Initialize and save as global default
  para init --path ~/Notes/para --save-config

Created Structure:
  <root>/
    1_Projects/    # Active work with outcomes
      _INDEX.md    # Index file for Projects
    2_Areas/       # Ongoing responsibilities
      _INDEX.md
    3_Resources/   # Reference materials
      _INDEX.md
    4_Archive/     # Completed/inactive items
      _INDEX.md

Notes:
  - Existing folders are left untouched (shows "exists:")
  - New folders get an _INDEX.md template
  - Use --save-config to set as global default in ~/.config/para/config.toml
""",
    )
    p_init.add_argument(
        "--path",
        help="Path to create PARA structure (default: current working directory)",
    )
    p_init.add_argument(
        "--save-config",
        action="store_true",
        help="Save this path as global default in ~/.config/para/config.toml",
    )
    p_init.set_defaults(func=cmd_init)

    # status
    p_status = subparsers.add_parser(
        "status",
        help="Show PARA structure status",
        description=(
            "Display the current PARA root and list contents of each PARA folder."
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Show PARA status
  para status

Output Format:
  Shows the resolved PARA root, then lists each folder with item counts:
    1_Projects (3 items)
      üìÅ Project-A/
      üìÅ Project-B/
      üìÑ notes.md
    2_Areas (2 items)
      ...

Notes:
  - Files/folders starting with _ or . are hidden from counts
  - Shows first 10 items per folder, then "... and N more"
  - Returns exit code 1 if PARA root is not configured
  - Does NOT prompt interactively; use 'para init' to set up first
""",
    )
    p_status.set_defaults(func=cmd_status)

    # project
    p_project = subparsers.add_parser(
        "project",
        help="Project management (list, create, archive)",
        description=(
            "Manage PARA projects. Defaults to 'list' when called without subcommand."
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # List all projects (default action)
  para project
  para project list

  # Create a new project
  para project create "My-Project"

  # Archive a completed project
  para project archive "My-Project"

Subcommands:
  list      List PARA projects
  create    Create a new project folder
  archive   Move project to archive
""",
    )
    project_sub = p_project.add_subparsers(dest="project_cmd")

    # project list
    p_proj_list = project_sub.add_parser(
        "list",
        help="List projects",
        description="List all PARA projects.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  para project list

Output Format:
  üìÅ Project-A
  üìÅ Project-B

Notes:
  - Projects are folders in "1_Projects/" (excluding _ and . prefixed)
""",
    )
    p_proj_list.set_defaults(func=cmd_project_list)

    # project create
    p_proj_create = project_sub.add_parser(
        "create",
        help="Create a new project",
        description="Create a new PARA project folder.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  para project create "Website-Redesign"

Created Structure:
  1_Projects/
    Website-Redesign/
      _INDEX.md    # Template with Outcome, Status, Key Files, Notes sections

Project Naming:
  - Use kebab-case (my-project) or PascalCase (MyProject)
  - Avoid spaces in names (they work but are awkward in CLI)

Notes:
  - Existing folders are not overwritten (shows warning)
""",
    )
    p_proj_create.add_argument(
        "name",
        help="Project name (use kebab-case or PascalCase, avoid spaces)",
    )
    p_proj_create.set_defaults(func=cmd_project_create)

    # project archive
    p_proj_archive = project_sub.add_parser(
        "archive",
        help="Archive a completed project",
        description="Move a project from 'Projects' to 'Archive'.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  para project archive "Completed-Project"

Result:
  Moves: 1_Projects/Completed-Project/ ‚Üí 4_Archive/projects/Completed-Project/

Notes:
  - Fails if source project folder doesn't exist
  - Fails if destination already exists in archive
""",
    )
    p_proj_archive.add_argument(
        "name",
        help="Project name to archive (must exist in 1_Projects/)",
    )
    p_proj_archive.set_defaults(func=cmd_project_archive)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 0

    if args.command == "project" and not args.project_cmd:
        # Default to list
        return cmd_project_list(args)

    if hasattr(args, "func"):
        return args.func(args)

    parser.print_help()
    return 0


if __name__ == "__main__":
    sys.exit(main())
